<?xml version="1.0"?>
<Menu>
	<Item name="网站文件夹" tv="964224" last="1">
		<Item name="百度" tv="964560">run,www.baidu.com</Item>
		<Item name="虎牙" tv="962096">run,www.huya.com</Item>
		<Item name="斗鱼" tv="962656">run, www.douyu.com</Item>
		<Item name="ahk中文论坛autoahk" tv="962320">run,www.autoahk.com</Item>
		<Item name="ahk官网论坛autohotkey" tv="963216">run, www.autohotkey.com</Item>
		<Item name="github" tv="964336">run,https:github.com</Item>
		<Item name="卡牌card目录" tv="963664">run,G:\我的AHK程序\游戏脚本\lol脚本集合\HX英雄联盟卡牌极速切牌</Item>
		<Item name="云顶之奕" tv="963776">run,G:\我的AHK程序\游戏脚本\HX云顶之奕挂机脚本</Item>
		<Item name="我的ahk工程" tv="961984">run,G:\我的AHK程序\我的工程</Item>
		<Item name="超级命令目录" tv="962768">run,G:\我的AHK程序\我的工程\超级命令</Item>
		<Item name="gitee" tv="961424">run, https://gitee.com/</Item>
		<Item name="必应" tv="962880">run,https://cn.bing.com/</Item>
		<Item name="bilibilib站" tv="963440">run,https://www.bilibili.com/</Item>
		<Item name="打字练习网站" tv="963888">run,https://dazi.kukuw.com/
run,https://www.bilibili.com/video/av57373164?from=search&amp;seid=7505871621684040908</Item>
		<Item name="正则表达式帮助" tv="964000">run,C:\Users\hetong\Documents\Tencent Files\2397633100\FileRecv\55分钟学会正则表达式.DOC</Item>
		<Item name="c++中文网" tv="960864">run,http://c.biancheng.net/view/151.html</Item>
		<Item name="c++chm" tv="120919632">run,G:\书籍\C++手册\cppreference-zh-20191207.chm</Item>
		<Item name="leedcode" tv="120920304">run,https://leetcode-cn.com</Item>
		<Item name="linux命令大全" tv="120918176">run,https://man.linuxde.net/</Item>
		<Item name="google" tv="120919072">run,www.google.com</Item>
		<Item name="autohotkey目录" tv="120919744">run,C:\Program Files\AutoHotkey</Item>
		<Item name="嗨正则" tv="120918400">run,https://hiregex.com/</Item>
		<Item name="音乐" tv="120919296">run,http://tool.liumingye.cn/music/?page=searchPage</Item></Item>
	<Item name="软件" tv="120919968">
		<Item name="词典" tv="120920416">run,C:\Users\hetong\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\网易有道词典.lnk</Item>
		<Item name="音乐" tv="120920080">run,C:\ProgramData\Microsoft\Windows\Start Menu\Programs\网易云音乐.lnk</Item>
		<Item name="cherry笔记" tv="120916944">run,G:\CherryTree\bin\cherrytree.exe</Item>
		<Item name="搜索" tv="120917952">Run, everything, F:\everything,</Item>
		<Item name="画图可汗" tv="120917056">run,F:\绘图软件\SmoothDraw\SmoothDraw4.exe F:\绘图软件\模板.sddoc</Item>
		<Item name="tgp" tv="120917280">Run,*RunAs WeGame,E:\wegeme,</Item>
		<Item name="录制" tv="120917504">run,bdcam.exe,F:\Bandicam</Item>
		<Item name="百度网盘" tv="120918736">run,baidunetdisk.exe,F:\BaiduNetdisk</Item>
		<Item name="截图" tv="120918848">run,FSCapture.exe,C:\Program Files (x86)\FastStone Capture\
</Item>
		<Item name="秒表" tv="623472">run,G:\我的AHK程序\脚本范例\ahkexample\各种脚本\其他合集\AHK 快餐店文中脚本\4.1-4.2计时器_闹钟 13秒表\13.秒表.ahk</Item>
		<Item name="gif录屏" tv="622016">run,F:\gif\屏幕录制ScreenToGif 2.34.1.exe</Item>
		<Item name="正则表达式ahk" tv="621904">run,C:\Users\hetong\Desktop\我的AHK程序\Adventure\Tools\Expressive\Expressive.ahk</Item>
		<Item name="正则表达式buddy" tv="622128">run, F:\正则表达式\RegexBuddy4.9.exe</Item>
		<Item name="按键显示" tv="622352">run,G:\我的AHK程序\我的工程\KeyPress-OSD-master（按键显示工具）\keycastow\keycastow.exe</Item></Item>
	<Item name="命令" tv="622464">
		<Item name="关机" tv="622576">msgbox, no this command</Item>
		<Item name="窗口置顶" tv="120681424">MouseGetPos, MouseX, MouseY, MouseWin
; 似乎有必要首先关闭任何现有的透明度:
WinSet, AlwaysOnTop, TOGGLE , ahk_id %MouseWin%</Item>
		<Item name="vim操作说明" tv="120681984">CommandText =
    (% 
重要的概念
	增：
		a/A(append)   i/i(insert)  o/O(open a line)
	删：
		diw(delete inner word)   daw(delete around word)  dd(delete a line word)
		x 删除一个字符  
		s 删除一个字符并进入插入模式 S 删除一行进入插入模式
		D 删除当前到行尾 
		C 删除当前到行尾巴进入插入模式
		删除不剪切  "_dd
	改：
		c (change as word)  ci字符(例如：ci" 删除引号里面的内容，并改成插入模式)   ct字符(删除到字符的内容，并改成插入模式)
	查：
		f字符(向前查找字符)   F字符(向后查找字符)  ;(重复上一个命名)
		命令模式下：   /字符(高亮字符，并向前查)   ?字符(高亮字符，并向后查)
	复制 y  复制到行首 y0  复制到行尾 y$  复制到( yF(    yi(    yt)


	替换:
		:s/(obj)/(value)/c
			范围：%s 表示全文 5s 第5行  .,+3当前行和接下来两行  %s全文
			c:表示需要确认-&gt; y n  1  a
			g:表示行中所有

	光标移动：
		h j k l (左 下 上  右)
		w(前字符)   b()
		:数字   数字G    gg   G    0(行首)  $(行尾) 
		
		ctrl+o(向后跳转)   ctrl+i(向前跳转)
		zz:行光标屏幕中心  zt 行光标屏幕顶部  zb行光标屏幕底部
		L:定位屏幕底部
		H:定位到屏幕顶
		
	翻页：
		Ctrl+f(forward  page)   ctrl+b(back page)
		ctrl+e(屏幕向下滚动一行)  ctrl+y(屏幕向上滚动一行)
		ctrl+d(down)   ctrl+u()
	
	编辑：
		u(撤销上一步的操作)    Ctrl+r(恢复上一步被撤销的操作)
	设置：
		set: clipboard=unnamed
		set: hlsearch  
		set: nohlsearch
	
	jkhl：单个光标移动
	a，A
	i , I
	o, O 
	x 
	w
	b
	daw diw d$ d0   dw db  
	caw ciw  c$ c0  cw cb  ci"  ci}  ci)  
	} {  段落跳转
	[[  ]] 函数跳转  
	% 跳转到匹配的括号
	ma 标记位置a,  `a 调转到a处， ‘a跳转到a行首

	宏录制：
		qa：录制到a寄存, q退出录制
		@a:执行a

	寄存器：
		"+:默认寄存器，复制，剪切命令会存到这里
		"0:最近复制的内容
		"1-9:最近剪切的内容
		"a-z:可以选择复制剪切的的寄存器
		"A-Z:内容归家到a-z里面
		命令模式使用寄存器内容：ctrl+" 然后输入寄存器名字
	vscode:
		gh 鼠标悬停效果  gd 跳转定义处
) 
Instruction := CommandText
Content := ""
TaskDialog(Instruction, Content, "", 0x1, 0)
run,C:\Users\hetong\Desktop\我的AHK程序\自动化办公\vim.png 


TaskDialog(Instruction, Content := "", Title := "", Buttons := 1, IconID := 0, IconRes := "", Owner := 0x10010) {
    Local hModule, LoadLib, Ret

    If (IconRes != "") {
        hModule := DllCall("GetModuleHandle", "Str", IconRes, "Ptr")
        LoadLib := !hModule
            &amp;&amp; hModule := DllCall("LoadLibraryEx", "Str", IconRes, "UInt", 0, "UInt", 0x2, "Ptr")
    } Else {
        hModule := 0
        LoadLib := False
    }

    DllCall("TaskDialog"
        , "Ptr" , Owner        ; hWndParent
        , "Ptr" , hModule      ; hInstance
        , "Ptr" , &amp;Title       ; pszWindowTitle
        , "Ptr" , &amp;Instruction ; pszMainInstruction
        , "Ptr" , &amp;Content     ; pszContent
        , "Int" , Buttons      ; dwCommonButtons
        , "Ptr" , IconID       ; pszIcon
        , "Int*", Ret := 0)    ; *pnButton

    If (LoadLib) {
        DllCall("FreeLibrary", "Ptr", hModule)
    }

    Return {1: "OK", 2: "Cancel", 4: "Retry", 6: "Yes", 7: "No", 8: "Close"}[Ret]
}</Item>
		<Item name="ipconfig" tv="1140944">#include &lt;runcmd&gt;
#include &lt;log4ahk&gt;
rtn := cmd.run("ifconfig")
log.info(rtn)</Item>
		<Item name="test" tv="954880">msgbox, test</Item>
		<Item name="mathematica" tv="954992">
			<Item name="转换为c语言" tv="957456">
inputvar = 
(
CForm[expr]
)
	clipboard:=inputvar </Item></Item></Item>
	<Item name="@ahk" tv="955104">
		<Item name="帮助手册" tv="953648">run,https://www.autoahk.com/help/autohotkey/zh-cn/docs/AutoHotkey.htm</Item>
		<Item name="开头设置" tv="956560">#NoEnv
#KeyHistory 0
#MaxThreads 255
#MaxMem 4095
#MaxThreadsBuffer On
#MaxHotkeysPerInterval 99000000
#HotkeyInterval 99000000
#SingleInstance Force
ListLines Off
Process, Priority, , R
SetTitleMatchMode fast
SetBatchLines, -1
SetKeyDelay, -1, -1, -1
SetMouseDelay, -1
SetWinDelay, -1
SetControlDelay, -1
SetDefaultMouseSpeed, 0
CoordMode, ToolTip , Screen
CommandText =
    (%
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
#NoEnv
#KeyHistory 0
#MaxThreads 255
#MaxMem 4095
#MaxThreadsBuffer On
#MaxHotkeysPerInterval 99000000
#HotkeyInterval 99000000
#SingleInstance Force
ListLines Off
Process, Priority, , R
SetTitleMatchMode fast
SetBatchLines, -1
SetKeyDelay, -1, -1, -1
SetMouseDelay, -1
SetWinDelay, -1
SetControlDelay, -1
SetDefaultMouseSpeed, 0
CoordMode, ToolTip , Screen 
    )    
clipboard:=CommandText</Item>
		<Item name="快捷输入模板" tv="954320">CommandText =
(%
CommandText =
`(%
替换为自己的命令 
`)    
clipboard:=CommandText
)    
clipboard:=CommandText</Item>
		<Item name="include库" tv="956784">CommandText =
(%
#Include &lt;log4ahk&gt;
#Include &lt;my_lib&gt;
)
clipboard:=CommandText</Item>
		<Item name="字符串转双引号其他语言" tv="954432">run,G:\我的AHK程序\我的工程\字符片段转延续片段\字符串转双引号.ahk</Item>
		<Item name="字符串转延续片段" tv="954208">run,G:\我的AHK程序\我的工程\字符片段转延续片段\字符片段转延续片段.ahk</Item>
		<Item name="脚本库" tv="953872">
			<Item name="json_feiyue_源码" tv="956112">c=
(%
;------------------------------
;  JSon.ahk - v2.1  By FeiYue
;------------------------------


json_toobj(s)  ; JSon字符串转AHK对象
{
  static rep:=[ ["\\","\u005c"], ["\""",""""], ["\/","/"]
    , ["\r","``r"], ["\n","``n"], ["\t","``t"]
    , ["\b","``b"], ["\f","``f"] ]
  if !(p:=RegExMatch(s, "[\{\[]", r))
    return
  SetBatchLines, % (bch:=A_BatchLines)?"-1":"-1"
  stack:=[], obj:=arr:=[], is_arr:=(r="[")
  , key:=(is_arr ? 1:""), keyok:=0
  While p:=RegExMatch(s, "\S", r, p+StrLen(r))
  {
    if (r="{" or r="[")  ; 如果是 左括号
    {
      stack.Push(is_arr, arr), arr[key]:=[], arr:=arr[key]
      , is_arr:=(r="["), key:=(is_arr ? 1:""), keyok:=0
    }
    else if (r="}" or r="]")  ; 如果是 右括号
    {
      if !stack.Length()
        Break
      arr:=stack.Pop(), is_arr:=stack.Pop()
      , key:=(is_arr ? arr.Length():""), keyok:=0
    }
    else if (r=",")  ; 如果是 逗号
    {
      key:=(is_arr ? Floor(key)+1:""), keyok:=0
    }
    else if (r="""")  ; 如果是 双引号
    {
      if RegExMatch(s, """((?:[^""\\]|\\[\s\S])*)""", r, p)!=p
        Break
      if InStr(r1, "\")
      {
        For k,v in rep
          r1:=StrReplace(r1, v[1], v[2])
        v:="", k:=1
        While i:=RegExMatch(r1, "\\u[0-9A-Fa-f]{4}",, k)
          v.=SubStr(r1,k,i-k) . Chr("0x" SubStr(r1,i+2,4)), k:=i+6
        r1:=v . SubStr(r1,k)
      }
      if (!is_arr and keyok=0)
      {
        p+=StrLen(r)
        if RegExMatch(s, "\s*:", r, p)!=p
          Break
        key:=r1, keyok:=1
      }
      else arr[key]:=r1
    }
    else  ; 如果是 true、false、null、数字
    {
      if RegExMatch(s, "[\w\+\-\.]+", r, p)!=p
        Break
      arr[key]:=(r=="true" ? 1:r=="false" ? 0:r=="null" ? "":r+0)
    }
  }
  SetBatchLines, %bch%
  return obj
}

json_fromobj(obj, space:="")  ; AHK对象转JSon字符串
{
  ;-------------------
  ; 默认不替换 "/--&gt;\/" 与 特殊html字符&lt;、&gt;、&amp;
  ;-------------------
  static rep:=[ ["\\","\"], ["\""",""""]  ; , ["\/","/"]
    ; , ["\\u003c","&lt;"], ["\\u003e","&gt;"], ["\\u0026","&amp;"]
    , ["\r","``r"], ["\n","``n"], ["\t","``t"]
    , ["\b","``b"], ["\f","``f"] ]
  if !IsObject(obj)
  {
    if obj is Number  ; thanks lexikos
      return ([obj].GetCapacity(1) ? """" obj """" : obj)
    ;-------------------
    ; 布尔值在AHK中转为数字了
    ; if (obj=="true" or obj=="false" or obj=="null")
    ;   return obj
    ;-------------------
    For k,v in rep
      obj:=StrReplace(obj, v[2], v[1])
    ;-------------------
    ; 默认不替换 "Unicode字符--&gt;\uXXXX"
    ; While RegExMatch(obj, "[^\x20-\x7e]", k)
    ;   obj:=StrReplace(obj, k, Format("\u{:04x}",Ord(k)))
    ;-------------------
    return """" obj """"
  }
  is_arr:=1  ; 是简单数组
  For k,v in obj
    if (k!=A_Index) and !(is_arr:=0)
      Break
  s:="", space2:=space . "    ", f:=A_ThisFunc
  For k,v in obj
    s.= "``r``n" space2
    . (is_arr ? "" : """" Trim(%f%(k ""),"""") """: ")
    . %f%(v,space2) . ","
  return (is_arr?"[":"{") . Trim(s,",")
    . "``r``n" space . (is_arr?"]":"}")
}


s=
`(

{
    "name": "BeJson",
    "url": "http://www.bejson.com",
    "page": 88,
    "page2": "88",
    "isNonProfit": true,
    "address": {
        "street": "科技园路",
        "city": "江苏苏州",
        "country": "中国"
    },
    "links": [
        {
            "name": "Google",
            "url": "http://www.google.com"
        },
        {
            "name": "Baidu",
            "url": "http://www.baidu.com"
        },
        {
            "name": "SoSo",
            "url": "http://www.SoSo.com"
        }
    ]
}
`)

Goto, F1

F1::
t1:=A_TickCount
s:=json_fromobj(json_toobj(s))
t1:=A_TickCount-t1
MsgBox, 4096, %t1% ms, % SubStr(s,1,1000)
return
)
Clipboard := c
</Item>
			<Item name="win_ocr" tv="954656">c=
(%
#include &lt;log4ahk&gt;
#NoEnv
SetBatchLines, -1
Return

Esc:: ExitApp

^X::
hBitmap := HBitmapFromScreen(GetArea()*)
pIRandomAccessStream := HBitmapToRandomAccessStream(hBitmap)
DllCall("DeleteObject", "Ptr", hBitmap)
text := ocr(pIRandomAccessStream, "zh-Hans-CN")
MsgBox, % text
Return

GetArea() {
   area := []
   StartSelection(area)
   while !area.w
      Sleep, 100
   Return area
}
   
StartSelection(area) {
   handler := Func("Select").Bind(area)
   Hotkey, LButton, % handler, On
   ReplaceSystemCursors("IDC_CROSS")
}

Select(area) {
   static hGui := CreateSelectionGui()
   Hook := new WindowsHook(WH_MOUSE_LL := 14, "LowLevelMouseProc", hGui)
   Loop {
      KeyWait, LButton
      WinGetPos, X, Y, W, H, ahk_id %hGui%
   } until w &gt; 0
   ReplaceSystemCursors("")
   Hotkey, LButton, Off
   Hook := ""
   Gui, %hGui%:Show, Hide
   for k, v in ["x", "y", "w", "h"]
      area[v] := %v%
}

ReplaceSystemCursors(IDC = "")
{
   static IMAGE_CURSOR := 2, SPI_SETCURSORS := 0x57
        , exitFunc := Func("ReplaceSystemCursors").Bind("")
        , SysCursors := { IDC_APPSTARTING: 32650
                        , IDC_ARROW      : 32512
                        , IDC_CROSS      : 32515
                        , IDC_HAND       : 32649
                        , IDC_HELP       : 32651
                        , IDC_IBEAM      : 32513
                        , IDC_NO         : 32648
                        , IDC_SIZEALL    : 32646
                        , IDC_SIZENESW   : 32643
                        , IDC_SIZENWSE   : 32642
                        , IDC_SIZEWE     : 32644
                        , IDC_SIZENS     : 32645 
                        , IDC_UPARROW    : 32516
                        , IDC_WAIT       : 32514 }
   if !IDC {
      DllCall("SystemParametersInfo", UInt, SPI_SETCURSORS, UInt, 0, UInt, 0, UInt, 0)
      OnExit(exitFunc, 0)
   }
   else  {
      hCursor := DllCall("LoadCursor", Ptr, 0, UInt, SysCursors[IDC], Ptr)
      for k, v in SysCursors  {
         hCopy := DllCall("CopyImage", Ptr, hCursor, UInt, IMAGE_CURSOR, Int, 0, Int, 0, UInt, 0, Ptr)
         DllCall("SetSystemCursor", Ptr, hCopy, UInt, v)
      }
      OnExit(exitFunc)
   }
}

CreateSelectionGui() {
   Gui, New, +hwndhGui +Alwaysontop -Caption +LastFound +ToolWindow +E0x20 -DPIScale
   WinSet, Transparent, 130
   Gui, Color, FFC800
   Return hGui
}

LowLevelMouseProc(nCode, wParam, lParam) {
   static WM_MOUSEMOVE := 0x200, WM_LBUTTONUP := 0x202
        , coords := [], startMouseX, startMouseY, hGui
        , timer := Func("LowLevelMouseProc").Bind("timer", "", "")
   
   if (nCode = "timer") {
      while coords[1] {
         point := coords.RemoveAt(1)
         mouseX := point[1], mouseY := point[2]
         x := startMouseX &lt; mouseX ? startMouseX : mouseX
         y := startMouseY &lt; mouseY ? startMouseY : mouseY
         w := Abs(mouseX - startMouseX)
         h := Abs(mouseY - startMouseY)
         try Gui, %hGUi%: Show, x%x% y%y% w%w% h%h% NA
      }
   }
   else {
`(!hGui &amp;&amp; hGui := A_EventInfo)
      if (wParam = WM_LBUTTONUP)
         startMouseX := startMouseY := ""
      if (wParam = WM_MOUSEMOVE)  {
         mouseX := NumGet(lParam + 0, "Int")
         mouseY := NumGet(lParam + 4, "Int")
         if (startMouseX = "") {
            startMouseX := mouseX
            startMouseY := mouseY
         }
         coords.Push([mouseX, mouseY])
         SetTimer, % timer, -10
      }
      Return DllCall("CallNextHookEx", Ptr, 0, Int, nCode, UInt, wParam, Ptr, lParam)
   }
}

class WindowsHook {
   __New(type, callback, eventInfo := "", isGlobal := true) {
      this.callbackPtr := RegisterCallback(callback, "Fast", 3, eventInfo)
      this.hHook := DllCall("SetWindowsHookEx", "Int", type, "Ptr", this.callbackPtr
                                              , "Ptr", !isGlobal ? 0 : DllCall("GetModuleHandle", "UInt", 0, "Ptr")
                                              , "UInt", isGlobal ? 0 : DllCall("GetCurrentThreadId"), "Ptr")
   }
   __Delete() {
      DllCall("UnhookWindowsHookEx", "Ptr", this.hHook)
      DllCall("GlobalFree", "Ptr", this.callBackPtr, "Ptr")
   }
}

HBitmapFromScreen(X, Y, W, H) {
   HDC := DllCall("GetDC", "Ptr", 0, "UPtr")
   HBM := DllCall("CreateCompatibleBitmap", "Ptr", HDC, "Int", W, "Int", H, "UPtr")
   PDC := DllCall("CreateCompatibleDC", "Ptr", HDC, "UPtr")
   DllCall("SelectObject", "Ptr", PDC, "Ptr", HBM)
   DllCall("BitBlt", "Ptr", PDC, "Int", 0, "Int", 0, "Int", W, "Int", H
                   , "Ptr", HDC, "Int", X, "Int", Y, "UInt", 0x00CC0020)
   DllCall("DeleteDC", "Ptr", PDC)
   DllCall("ReleaseDC", "Ptr", 0, "Ptr", HDC)
   Return HBM
}

HBitmapToRandomAccessStream(hBitmap) {
   static IID_IRandomAccessStream := "{905A0FE1-BC53-11DF-8C49-001E4FC686DA}"
        , IID_IPicture            := "{7BF80980-BF32-101A-8BBB-00AA00300CAB}"
        , PICTYPE_BITMAP := 1
        , BSOS_DEFAULT   := 0
        
   DllCall("Ole32\CreateStreamOnHGlobal", "Ptr", 0, "UInt", true, "PtrP", pIStream, "UInt")
   
   VarSetCapacity(PICTDESC, sz := 8 + A_PtrSize*2, 0)
   NumPut(sz, PICTDESC)
   NumPut(PICTYPE_BITMAP, PICTDESC, 4)
   NumPut(hBitmap, PICTDESC, 8)
   riid := CLSIDFromString(IID_IPicture, GUID1)
   DllCall("OleAut32\OleCreatePictureIndirect", "Ptr", &amp;PICTDESC, "Ptr", riid, "UInt", false, "PtrP", pIPicture, "UInt")
   ; IPicture::SaveAsFile
   DllCall(NumGet(NumGet(pIPicture+0) + A_PtrSize*15), "Ptr", pIPicture, "Ptr", pIStream, "UInt", true, "UIntP", size, "UInt")
   riid := CLSIDFromString(IID_IRandomAccessStream, GUID2)
   DllCall("ShCore\CreateRandomAccessStreamOverStream", "Ptr", pIStream, "UInt", BSOS_DEFAULT, "Ptr", riid, "PtrP", pIRandomAccessStream, "UInt")
   ObjRelease(pIPicture)
   ObjRelease(pIStream)
   Return pIRandomAccessStream
}

CLSIDFromString(IID, ByRef CLSID) {
   VarSetCapacity(CLSID, 16, 0)
   if res := DllCall("ole32\CLSIDFromString", "WStr", IID, "Ptr", &amp;CLSID, "UInt")
      throw Exception("CLSIDFromString failed. Error: " . Format("{:#x}", res))
   Return &amp;CLSID
}


ocr(file, lang := "FirstFromAvailableLanguages")
{
   static OcrEngineStatics, OcrEngine, MaxDimension, LanguageFactory, Language, CurrentLanguage, BitmapDecoderStatics, GlobalizationPreferencesStatics
   if (OcrEngineStatics = "")
   {
      CreateClass("Windows.Globalization.Language", ILanguageFactory := "{9B0252AC-0C27-44F8-B792-9793FB66C63E}", LanguageFactory)
      CreateClass("Windows.Graphics.Imaging.BitmapDecoder", IBitmapDecoderStatics := "{438CCB26-BCEF-4E95-BAD6-23A822E58D01}", BitmapDecoderStatics)
      CreateClass("Windows.Media.Ocr.OcrEngine", IOcrEngineStatics := "{5BFFA85A-3384-3540-9940-699120D428A8}", OcrEngineStatics)
      DllCall(NumGet(NumGet(OcrEngineStatics+0)+6*A_PtrSize), "ptr", OcrEngineStatics, "uint*", MaxDimension)   ; MaxImageDimension
   }
   if (file = "ShowAvailableLanguages")
   {
      if (GlobalizationPreferencesStatics = "")
         CreateClass("Windows.System.UserProfile.GlobalizationPreferences", IGlobalizationPreferencesStatics := "{01BF4326-ED37-4E96-B0E9-C1340D1EA158}", GlobalizationPreferencesStatics)
      DllCall(NumGet(NumGet(GlobalizationPreferencesStatics+0)+9*A_PtrSize), "ptr", GlobalizationPreferencesStatics, "ptr*", LanguageList)   ; get_Languages
      DllCall(NumGet(NumGet(LanguageList+0)+7*A_PtrSize), "ptr", LanguageList, "int*", count)   ; count
      loop % count
      {
         DllCall(NumGet(NumGet(LanguageList+0)+6*A_PtrSize), "ptr", LanguageList, "int", A_Index-1, "ptr*", hString)   ; get_Item
         DllCall(NumGet(NumGet(LanguageFactory+0)+6*A_PtrSize), "ptr", LanguageFactory, "ptr", hString, "ptr*", LanguageTest)   ; CreateLanguage
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+8*A_PtrSize), "ptr", OcrEngineStatics, "ptr", LanguageTest, "int*", bool)   ; IsLanguageSupported
         if (bool = 1)
         {
            DllCall(NumGet(NumGet(LanguageTest+0)+6*A_PtrSize), "ptr", LanguageTest, "ptr*", hText)
            buffer := DllCall("Combase.dll\WindowsGetStringRawBuffer", "ptr", hText, "uint*", length, "ptr")
            text .= StrGet(buffer, "UTF-16") "``n"
         }
         ObjRelease(LanguageTest)
      }
      ObjRelease(LanguageList)
      return text
   }
   if (lang != CurrentLanguage) or (lang = "FirstFromAvailableLanguages")
   {
      if (OcrEngine != "")
      {
         ObjRelease(OcrEngine)
         if (CurrentLanguage != "FirstFromAvailableLanguages")
            ObjRelease(Language)
      }
      if (lang = "FirstFromAvailableLanguages")
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+10*A_PtrSize), "ptr", OcrEngineStatics, "ptr*", OcrEngine)   ; TryCreateFromUserProfileLanguages
      else
      {
         CreateHString(lang, hString)
         DllCall(NumGet(NumGet(LanguageFactory+0)+6*A_PtrSize), "ptr", LanguageFactory, "ptr", hString, "ptr*", Language)   ; CreateLanguage
         DeleteHString(hString)
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+9*A_PtrSize), "ptr", OcrEngineStatics, ptr, Language, "ptr*", OcrEngine)   ; TryCreateFromLanguage
      }
      if (OcrEngine = 0)
      {
         msgbox Can not use language "%lang%" for OCR, please install language pack.
         ExitApp
      }
      CurrentLanguage := lang
   }
   IRandomAccessStream := file
   DllCall(NumGet(NumGet(BitmapDecoderStatics+0)+14*A_PtrSize), "ptr", BitmapDecoderStatics, "ptr", IRandomAccessStream, "ptr*", BitmapDecoder)   ; CreateAsync
   WaitForAsync(BitmapDecoder)
   BitmapFrame := ComObjQuery(BitmapDecoder, IBitmapFrame := "{72A49A1C-8081-438D-91BC-94ECFC8185C6}")
   DllCall(NumGet(NumGet(BitmapFrame+0)+12*A_PtrSize), "ptr", BitmapFrame, "uint*", width)   ; get_PixelWidth
   DllCall(NumGet(NumGet(BitmapFrame+0)+13*A_PtrSize), "ptr", BitmapFrame, "uint*", height)   ; get_PixelHeight
   if (width &gt; MaxDimension) or (height &gt; MaxDimension)
   {
      msgbox Image is to big - %width%x%height%.``nIt should be maximum - %MaxDimension% pixels
      ExitApp
   }
   BitmapFrameWithSoftwareBitmap := ComObjQuery(BitmapDecoder, IBitmapFrameWithSoftwareBitmap := "{FE287C9A-420C-4963-87AD-691436E08383}")
   DllCall(NumGet(NumGet(BitmapFrameWithSoftwareBitmap+0)+6*A_PtrSize), "ptr", BitmapFrameWithSoftwareBitmap, "ptr*", SoftwareBitmap)   ; GetSoftwareBitmapAsync
   WaitForAsync(SoftwareBitmap)
   DllCall(NumGet(NumGet(OcrEngine+0)+6*A_PtrSize), "ptr", OcrEngine, ptr, SoftwareBitmap, "ptr*", OcrResult)   ; RecognizeAsync
   WaitForAsync(OcrResult)
   DllCall(NumGet(NumGet(OcrResult+0)+6*A_PtrSize), "ptr", OcrResult, "ptr*", LinesList)   ; get_Lines
   DllCall(NumGet(NumGet(LinesList+0)+7*A_PtrSize), "ptr", LinesList, "int*", count)   ; count
   loop % count
   {
      DllCall(NumGet(NumGet(LinesList+0)+6*A_PtrSize), "ptr", LinesList, "int", A_Index-1, "ptr*", OcrLine)
      DllCall(NumGet(NumGet(OcrLine+0)+7*A_PtrSize), "ptr", OcrLine, "ptr*", hText) 
      buffer := DllCall("Combase.dll\WindowsGetStringRawBuffer", "ptr", hText, "uint*", length, "ptr")
      text .= StrGet(buffer, "UTF-16") "``n"
      ObjRelease(OcrLine)
   }
   Close := ComObjQuery(IRandomAccessStream, IClosable := "{30D5A829-7FA4-4026-83BB-D75BAE4EA99E}")
   DllCall(NumGet(NumGet(Close+0)+6*A_PtrSize), "ptr", Close)   ; Close
   ObjRelease(Close)
   Close := ComObjQuery(SoftwareBitmap, IClosable := "{30D5A829-7FA4-4026-83BB-D75BAE4EA99E}")
   DllCall(NumGet(NumGet(Close+0)+6*A_PtrSize), "ptr", Close)   ; Close
   ObjRelease(Close)
   ObjRelease(IRandomAccessStream)
   ObjRelease(BitmapDecoder)
   ObjRelease(BitmapFrame)
   ObjRelease(BitmapFrameWithSoftwareBitmap)
   ObjRelease(SoftwareBitmap)
   ObjRelease(OcrResult)
   ObjRelease(LinesList)
   return text
}



CreateClass(string, interface, ByRef Class)
{
   CreateHString(string, hString)
   VarSetCapacity(GUID, 16)
   DllCall("ole32\CLSIDFromString", "wstr", interface, "ptr", &amp;GUID)
   result := DllCall("Combase.dll\RoGetActivationFactory", "ptr", hString, "ptr", &amp;GUID, "ptr*", Class)
   if (result != 0)
   {
      if (result = 0x80004002)
         msgbox No such interface supported
      else if (result = 0x80040154)
         msgbox Class not registered
      else
         msgbox error: %result%
      ExitApp
   }
   DeleteHString(hString)
}

CreateHString(string, ByRef hString)
{
    DllCall("Combase.dll\WindowsCreateString", "wstr", string, "uint", StrLen(string), "ptr*", hString)
}

DeleteHString(hString)
{
   DllCall("Combase.dll\WindowsDeleteString", "ptr", hString)
}

WaitForAsync(ByRef Object)
{
   AsyncInfo := ComObjQuery(Object, IAsyncInfo := "{00000036-0000-0000-C000-000000000046}")
   loop
   {
      DllCall(NumGet(NumGet(AsyncInfo+0)+7*A_PtrSize), "ptr", AsyncInfo, "uint*", status)   ; IAsyncInfo.Status
      if (status != 0)
      {
         if (status != 1)
         {
            DllCall(NumGet(NumGet(AsyncInfo+0)+8*A_PtrSize), "ptr", AsyncInfo, "uint*", ErrorCode)   ; IAsyncInfo.ErrorCode
            msgbox AsyncInfo status error: %ErrorCode%
            ExitApp
         }
         ObjRelease(AsyncInfo)
         break
      }
      sleep 10
   }
   DllCall(NumGet(NumGet(Object+0)+8*A_PtrSize), "ptr", Object, "ptr*", ObjectResult)   ; GetResults
   ObjRelease(Object)
   Object := ObjectResult
}
)
Clipboard := c</Item>
			<Item name="capture" tv="956896">run,G:\我的AHK程序\我的工程\dxgi_pixelgetcolor
c =
(%
#include &lt;my_lib&gt;

;gdip startup
if !DllCall("kernel32\GetModuleHandle", Str,"gdiplus", Ptr)
	DllCall("kernel32\LoadLibrary", Str,"gdiplus", Ptr)
VarSetCapacity(GdiplusStartupInput, 16, 0), GdiplusStartupInput := Chr(1)
DllCall("gdiplus\GdiplusStartup", UPtrP,pToken, Ptr,&amp;GdiplusStartupInput, Ptr,0)

Gui +AlwaysOnTop -DPIScale
Gui Margin, 15, 15
Gui Add, Pic, HwndhPic w800 h800 +Border	;演示窗口大小
Gui Show,x1000 y10

;==============================
;from data
vSize := 14 + 40 + A_ScreenWidth * A_ScreenHeight * 4
dxgi_init(0)
rtn := dxgi_pixelgetcolor(0, 0, p_vitmap_file, p_bitmap_info , p_bitmap_data, is_time_out)
dxgi_save2file("test.bmp")
loop
{
    dxgi_pixelgetcolor(0, 0, p_vitmap_file, p_bitmap_info , p_bitmap_data, is_time_out)
    hBitmap := GDIPlus_hBitmapFromPoint(p_vitmap_file, vSize)
    Show(hPic, hBitmap, 0, 0, 800, 800)
    DllCall("DeleteObject", "ptr", hBitmap)
}
return

f5::
;gdip shutdown
DllCall("gdiplus\GdiplusShutdown", UPtr,pToken)
if hModule := DllCall("kernel32\GetModuleHandle", Str,"gdiplus", Ptr)
	DllCall("kernel32\FreeLibrary", Ptr,hModule)
;==============================
ExitApp
return

;==================================================
;GdiPlus_SaveImageToBuffer() - Scripts and Functions - AutoHotkey Community
;https://autohotkey.com/board/topic/85523-gdiplus-saveimagetobuffer/

GDIPlus_hBitmapFromPoint( ByRef Buffer, nSize ) { ;  Last Modifed : 21-Jun-2011
; Adapted version by SKAN www.autohotkey.com/forum/viewtopic.php?p=383863#383863
; Original code   by Sean www.autohotkey.com/forum/viewtopic.php?p=147029#147029
 hData := DllCall("GlobalAlloc", UInt,2, UInt,nSize )
 pData := DllCall("GlobalLock",  UInt,hData )
 DllCall( "RtlMoveMemory", UInt,pData, UInt,Buffer, UInt,nSize )
 DllCall( "GlobalUnlock" , UInt,hData )
 DllCall( "ole32\CreateStreamOnHGlobal", UInt,hData, Int,True, UIntP,pStream )
 DllCall( "gdiplus\GdipCreateBitmapFromStream",  UInt,pStream, UIntP,pBitmap )
 DllCall( "gdiplus\GdipCreateHBITMAPFromBitmap", UInt,pBitmap, UIntP,hBitmap, UInt
,DllCall( "ntdll\RtlUlongByteSwap",UInt
,DllCall( "GetSysColor", Int,15 ) &lt;&lt;8 ) | 0xFF000000 )
 DllCall( "gdiplus\GdipDisposeImage", UInt,pBitmap )
 DllCall( NumGet( NumGet(1*pStream)+8 ), UInt,pStream ) ; IStream::Release
 Dllcall("GlobalFree", "Ptr", hData)
Return hBitmap
}


GDIPlus_hBitmapFromBuffer( ByRef Buffer, nSize ) { ;  Last Modifed : 21-Jun-2011
; Adapted version by SKAN www.autohotkey.com/forum/viewtopic.php?p=383863#383863
; Original code   by Sean www.autohotkey.com/forum/viewtopic.php?p=147029#147029
 hData := DllCall("GlobalAlloc", UInt,2, UInt,nSize )
 pData := DllCall("GlobalLock",  UInt,hData )
 DllCall( "RtlMoveMemory", UInt,pData, UInt,&amp;Buffer, UInt,nSize )
 DllCall( "GlobalUnlock" , UInt,hData )
 DllCall( "ole32\CreateStreamOnHGlobal", UInt,hData, Int,True, UIntP,pStream )
 DllCall( "gdiplus\GdipCreateBitmapFromStream",  UInt,pStream, UIntP,pBitmap )
 DllCall( "gdiplus\GdipCreateHBITMAPFromBitmap", UInt,pBitmap, UIntP,hBitmap, UInt
,DllCall( "ntdll\RtlUlongByteSwap",UInt
,DllCall( "GetSysColor", Int,15 ) &lt;&lt;8 ) | 0xFF000000 )
 DllCall( "gdiplus\GdipDisposeImage", UInt,pBitmap )
 DllCall( NumGet( NumGet(1*pStream)+8 ), UInt,pStream ) ; IStream::Release
 Dllcall("GlobalFree", "Ptr", hData)
Return hBitmap
}

;----------------------
; 显示内存图像  By FeiYue
;----------------------
Show(hwnd, hBM, x1, y1, x2, y2) {
	x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
	, hDC := DllCall("GetDC", "Ptr",hwnd, "Ptr")
	, mDC := DllCall("CreateCompatibleDC", "Ptr", hDC, "Ptr")
	, oBM := DllCall("SelectObject", "Ptr", mDC, "Ptr", hBM)
	rtn := DllCall("BitBlt", "Ptr", hDC, "Int",0, "Int",0, "Int",w, "Int",h, "Ptr",mDC, "Int",x, "Int",y, "UInt",0xCC0020)
	DllCall("SelectObject", "Ptr", mDC, "Ptr", oBM)
	, DllCall("ReleaseDC", "Ptr",hwnd, "Ptr",hDC)
	, DllCall("DeleteDC", "Ptr",mDC)
}
)
Clipboard := c</Item>
			<Item name="右键选择范围" tv="953760">c=
(%
;------------------------------
; 右键选择屏幕范围   By FeiYue
;------------------------------


右键选择屏幕范围(x1,y1,x2,y2)
右键选择屏幕范围(ByRef x1="", ByRef y1="", ByRef x2="", ByRef y2="")
{
  KeyWait, RButton
  For k,v in StrSplit("RButton,Left,Right,Up,Down", ",")
    Hotkey, % v, GetRange_KeyOff, On
  if (0)
  {
    GetRange_KeyOff:
    return
  }
  Gui, GetRange: Destroy
  Gui, % "GetRange: +AlwaysOnTop -Caption +ToolWindow"
    . " +Hwndid -DPIScale +E0x08000000"
  ok:=0
  CoordMode, Mouse, Screen
  While !GetKeyState("Ctrl","P")
  {
    Sleep, 50
    ToolTip, 按右键拖选范围``n方向键微调位置``n再次点右键确定
    MouseGetPos, x2, y2
    if (ok=0)
    {
      if GetKeyState("RButton","P")
        ok:=1, x1:=x2, y1:=y2
    }
    else if (ok=1)
    {
      GetKeyState("Left","P")  &amp;&amp; x1--
      GetKeyState("Right","P") &amp;&amp; x1++
      GetKeyState("Up","P")    &amp;&amp; y1--
      GetKeyState("Down","P")  &amp;&amp; y1++
      w:=Floor(Abs(x1-x2)), h:=Floor(Abs(y1-y2))
      x:=Floor(Min(x1,x2)), y:=Floor(Min(y1,y2))
      d:=2, x-=d, y-=d, w+=2*d, h+=2*d, i:=w-d, j:=h-d
      s:="0-0 " (w "-0 ") (w "-" h) (" 0-" h) " 0-0  "
      . (d "-" d) " " (i "-" d) " " (i "-" j) " " (d "-" j) " " (d "-" d)
      WinSet, Region, %s%, ahk_id %id%
      Gui, GetRange: Color, % (A_MSec&lt;500 ? "Red":"Blue")
      Gui, GetRange: Show, NA x%x% y%y% w%w% h%h%
      if !GetKeyState("RButton","P")
        ok:=2
    }
    else if (ok=2)
    {
      GetKeyState("Left","P")  &amp;&amp; x--
      GetKeyState("Right","P") &amp;&amp; x++
      GetKeyState("Up","P")    &amp;&amp; y--
      GetKeyState("Down","P")  &amp;&amp; y++
      Gui, GetRange: Color, % (A_MSec&lt;500 ? "Red":"Blue")
      Gui, GetRange: Show, NA x%x% y%y%
      if GetKeyState("RButton","P")
        Break
    }
  }
  x1:=x+d, y1:=y+d, x2:=x+w-1-d, y2:=y+h-1-d
  Gui, GetRange: Destroy
  ToolTip
  KeyWait, RButton
  For k,v in StrSplit("RButton,Left,Right,Up,Down", ",")
    Hotkey, % v, Off
  return (x1 "," y1 "," x2 "," y2)
}
)
Clipboard := c</Item></Item></Item>
</Menu>
