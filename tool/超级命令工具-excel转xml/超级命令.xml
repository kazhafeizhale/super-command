<?xml version="1.0"?>
<Menu>
	<Item name="@网站文件夹" tv="9848096">
		<Item name="百度" tv="9846304">;v2
run("www.baidu.com")</Item>
		<Item name="xml转义" tv="9846416">run,http://lzltool.com/XmlEscape</Item>
		<Item name="emigi" tv="9846752">run,https://www.emojiall.com/zh-hans/emoji-translator-page?text=%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7</Item>
		<Item name="时间戳" tv="9846864">run,https://shijianchuo.net/</Item>
		<Item name="windows快捷键" tv="9846976">run,https://support.microsoft.com/zh-cn/windows/windows-%E7%9A%84%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F-dcc61a57-8ff0-cffe-9796-cb9706c75eec</Item>
		<Item name="spdlog" tv="9847200">run,G:\c++学习\vsproject\spd_log\include</Item>
		<Item name="gif网站" tv="9847312">run,https://giphy.com/search/4k/
run,https://gifer.com/en/4CND</Item>
		<Item name="opencv ahk 绑定v2" tv="9847424">run, https://github.com/thqby/opencv_ahk</Item>
		<Item name="虎牙" tv="10187952">run,www.huya.com</Item>
		<Item name="斗鱼" tv="10187616">run, www.douyu.com</Item>
		<Item name="plantuml帮助网站" tv="10186384">run, https://plantuml.com/zh/guide</Item>
		<Item name="ahk中文论坛autoahk" tv="10188624">run,www.autoahk.com</Item>
		<Item name="ahk官网论坛autohotkey" tv="10186272">run, www.autohotkey.com</Item>
		<Item name="github" tv="10189184">run,https:github.com</Item>
		<Item name="github加速" tv="10185824">run,F:\github\dev-sidecar\dev-sidecar.exe</Item>
		<Item name="github镜像" tv="10186720">run,https://hub.fastgit.org/</Item>
		<Item name="书籍下载" tv="10185488">run,https://zh.ng1lib.org</Item>
		<Item name="cpp2ahk" tv="10188736">run,G:\c++学习\vsproject\repos\cpp2ahk\cpp2ahk</Item>
		<Item name="书籍目录" tv="10185376">run,G:\书籍</Item>
		<Item name="imgui文档" tv="10186832">run, https://pixtur.github.io/mkdocs-for-imgui/site/FONTS/</Item>
		<Item name="记单词" tv="10188400">run,https://www.appinn.com/typing-learner/</Item>
		<Item name="imgui例子" tv="10187392">run,https://github.com/ocornut/imgui/issues/2529</Item>
		<Item name="文档软件" tv="10187728">run, https://zealdocs.org/download.html#windows
run,https://www.jianshu.com/p/598f18ca6963
run,F:\zoo文档软件\zeal-portable-0.6.1-windows-x64\zeal.exe</Item>
		<Item name="卡牌card目录" tv="10185600">run,G:\我的AHK程序\游戏脚本\lol脚本集合\HX英雄联盟卡牌极速切牌
run,G:\c++学习\vsproject\imguitest\imgui-docking-1.88\imgui模板\main\Release</Item>
		<Item name="云顶之奕" tv="10186160">run,G:\我的AHK程序\游戏脚本\HX云顶之奕挂机脚本
run,G:\我的AHK程序\我的工程\imgui_autohotkey\autohotkey_v2\云顶之弈</Item>
		<Item name="我的ahk工程" tv="10186944">run,G:\我的AHK程序\我的工程</Item>
		<Item name="计算器" tv="10187168">run,*RunAs F:\计算器\MathApp.exe</Item>
		<Item name="超级命令目录" tv="10186496">run,% A_args[1]</Item>
		<Item name="gitee" tv="10187056">run, https://gitee.com/</Item>
		<Item name="必应" tv="10187504">run,https://cn.bing.com/</Item>
		<Item name="必应图片" tv="10186608">run,https://cn.bing.com/images/trending?form=Z9LH</Item>
		<Item name="google谷歌" tv="10185712">run, www.google.com</Item>
		<Item name="youtube" tv="10188512">run,https://www.youtube.com/</Item>
		<Item name="bilibilib站" tv="10185936">run,https://www.bilibili.com/</Item>
		<Item name="打字练习网站" tv="10186048">;run,https://dazi.kukuw.com/
;run,https://www.bilibili.com/video/av57373164?from=search&amp;seid=7505871621684040908
;run,https://www.bilibili.com/video/BV1754y127N6?spm_id_from=333.337.search-card.all.click
run,https://10fastfingers.com/
;run,https://www.typingtest.com/
;run,https://www.keybr.com/
run,https://www.typingclub.com/da-zi
</Item>
		<Item name="正则表达式帮助" tv="10187280">run,C:\Users\kzf\Documents\Tencent Files\FileRecv\55分钟学会正则表达式.DOC</Item>
		<Item name="vscode命令" tv="10188848">run,https://code.visualstudio.com/api/references/commands#simple-commands</Item>
		<Item name="c++ cpp 中文网" tv="10188176">run,http://c.biancheng.net/cplus/</Item>
		<Item name="cpp c++ chm" tv="10188960">run,G:\书籍\C++手册\cppreference-zh-20191207.chm</Item>
		<Item name="leedcode" tv="10189072">run,https://leetcode-cn.com</Item>
		<Item name="linux命令大全" tv="10187840">run,https://man.linuxde.net/</Item>
		<Item name="开机" tv="10188064">start</Item>
		<Item name="mysql" tv="10188288">run,https://www.mysql.com/</Item>
		<Item name="autohotkey目录" tv="10193792">run,C:\Program Files\AutoHotkey</Item>
		<Item name="嗨正则" tv="10191552">run,https://hiregex.com/</Item>
		<Item name="计时器" tv="10192000">;Run, *RunAs E:\定时器\Easy Cat Timer v1.0.0.0\Easy Cat Timer.exe,
run,https://cn.easycattimer.com/</Item>
		<Item name="音乐" tv="10193904">run,http://tool.liumingye.cn/music/?page=searchPage</Item>
		<Item name="thqby gitee" tv="10193344">run,https://gitee.com/barbarla/AHK_Lib/tree/master</Item>
		<Item name="电影" tv="10193568">run,https://lab.liumingye.cn/vodplay/67631-1-1.html</Item>
		<Item name="小众软件" tv="10195248">run,https://www.appinn.com/</Item>
		<Item name="vscode笔记" tv="10194464">run,G:\vs code\Microsoft VS Code\Code.exe G:\vscode笔记\note</Item>
		<Item name="opencv文档" tv="10192560">run, https://docs.opencv.org/4.x/dc/d84/group__core__basic.html#ga606feabe3b50ab6838f1ba89727aa07a
run,https://docs.opencv.org/</Item>
		<Item name="opencv优秀文章" tv="10192896">run,https://www.stubbornhuang.com/1603/</Item>
		<Item name="软件工具" tv="10194128">run,https://www.nirsoft.net/utils/index.html</Item>
		<Item name="英语听力软件" tv="10191776">run,F:\media_play_study\Media_Study_Player.exe</Item>
		<Item name="英语youtube视频" tv="10191888">run,https://www.languagereactor.com/?utm_source=appinn.com</Item>
		<Item name="英语youtube" tv="10194016">run,https://youglish.com/?utm_source=appinn.com</Item>
		<Item name="图片image上传" tv="10191664">run,https://postimg.cc/GTvp4dqx</Item>
		<Item name="gdip" tv="10192112">run,http://www.yfvb.com/help/gdiplus/index.htm?page=gdipcreatehbitmapfrombitmap.htm
run,https://wizardforcel.gitbooks.io/gdip-basic/content/4.html
run,http://www.yfvb.com/help/gdi/index.htm
run,https://www.bilibili.com/video/BV1zz411q7qC?spm_id_from=333.337.search-card.all.click</Item>
		<Item name="测试" tv="10193456">测试中文</Item>
		<Item name="tmp" tv="10195024">run,% "G:\vs code\Microsoft VS Code\Code.exe " A_args[1] "\cmd\tmp\tmp.ahk"</Item></Item>
	<Item name="@命令" tv="10194240">
		<Item name="vim操作说明" tv="10192224">CommandText =
    (% 
重要的概念
	增：
		a/A(append)   i/i(insert)  o/O(open a line)
	删：
		diw(delete inner word)   daw(delete around word)  dd(delete a line word)
		x 删除一个字符  
		s 删除一个字符并进入插入模式 S 删除一行进入插入模式
		D 删除当前到行尾 
		C 删除当前到行尾巴进入插入模式
		删除不剪切  "_dd
	改：
		c (change as word)  ci字符(例如：ci" 删除引号里面的内容，并改成插入模式)   ct字符(删除到字符的内容，并改成插入模式)
	查：
		f字符(向前查找字符)   F字符(向后查找字符)  ;(重复上一个命名)
		命令模式下：   /字符(高亮字符，并向前查)   ?字符(高亮字符，并向后查)
	复制 y  复制到行首 y0  复制到行尾 y$  复制到( yF(    yi(    yt)


	替换:
		:s/(obj)/(value)/c
			范围：%s 表示全文 5s 第5行  .,+3当前行和接下来两行  %s全文
			c:表示需要确认-&gt; y n  1  a
			g:表示行中所有

	光标移动：
		h j k l (左 下 上  右)
		w(前字符)   b()
		:数字   数字G    gg   G    0(行首)  $(行尾) 
		
		ctrl+o(向后跳转)   ctrl+i(向前跳转)
		zz:行光标屏幕中心  zt 行光标屏幕顶部  zb行光标屏幕底部
		L:定位屏幕底部
		H:定位到屏幕顶
		
	翻页：
		Ctrl+f(forward  page)   ctrl+b(back page)
		ctrl+e(屏幕向下滚动一行)  ctrl+y(屏幕向上滚动一行)
		ctrl+d(down)   ctrl+u()
	
	编辑：
		u(撤销上一步的操作)    Ctrl+r(恢复上一步被撤销的操作)
	设置：
		set: clipboard=unnamed
		set: hlsearch  
		set: nohlsearch
	
	jkhl：单个光标移动
	a，A
	i , I
	o, O 
	x 
	w
	b
	daw diw d$ d0   dw db  
	caw ciw  c$ c0  cw cb  ci"  ci}  ci)  
	} {  段落跳转
	[[  ]] 函数跳转  
	% 跳转到匹配的括号
	ma 标记位置a,  `a 调转到a处， ‘a跳转到a行首

	宏录制：
		qa：录制到a寄存, q退出录制
		@a:执行a

	寄存器：
		"+:默认寄存器，复制，剪切命令会存到这里
		"0:最近复制的内容
		"1-9:最近剪切的内容
		"a-z:可以选择复制剪切的的寄存器
		"A-Z:内容归家到a-z里面
		命令模式使用寄存器内容：ctrl+" 然后输入寄存器名字
	vscode:
		gh 鼠标悬停效果  gd 跳转定义处
) 
Instruction := CommandText
Content := ""
TaskDialog(Instruction, Content, "", 0x1, 0)
run,C:\Users\kzf\Desktop\我的AHK程序\自动化办公\vim.png 


TaskDialog(Instruction, Content := "", Title := "", Buttons := 1, IconID := 0, IconRes := "", Owner := 0x10010) {
    Local hModule, LoadLib, Ret

    If (IconRes != "") {
        hModule := DllCall("GetModuleHandle", "Str", IconRes, "Ptr")
        LoadLib := !hModule
            &amp;&amp; hModule := DllCall("LoadLibraryEx", "Str", IconRes, "UInt", 0, "UInt", 0x2, "Ptr")
    } Else {
        hModule := 0
        LoadLib := False
    }

    DllCall("TaskDialog"
        , "Ptr" , Owner        ; hWndParent
        , "Ptr" , hModule      ; hInstance
        , "Ptr" , &amp;Title       ; pszWindowTitle
        , "Ptr" , &amp;Instruction ; pszMainInstruction
        , "Ptr" , &amp;Content     ; pszContent
        , "Int" , Buttons      ; dwCommonButtons
        , "Ptr" , IconID       ; pszIcon
        , "Int*", Ret := 0)    ; *pnButton

    If (LoadLib) {
        DllCall("FreeLibrary", "Ptr", hModule)
    }

    Return {1: "OK", 2: "Cancel", 4: "Retry", 6: "Yes", 7: "No", 8: "Close"}[Ret]
}</Item>
		<Item name="关机" tv="10194912">msgbox, no this command</Item>
		<Item name="窗口置顶" tv="10194352">MouseGetPos, MouseX, MouseY, MouseWin
; 似乎有必要首先关闭任何现有的透明度:
WinSet, AlwaysOnTop, TOGGLE , ahk_id %MouseWin%</Item>
		<Item name="ipconfig" tv="10193232">#include &lt;runcmd&gt;
#include &lt;log4ahk&gt;
rtn := cmd.run("ifconfig")
log.info(rtn)</Item>
		<Item name="mathematica" tv="10192672">
			<Item name="转换为c语言" tv="10194576">
inputvar = 
(
CForm[expr]
)
	clipboard:=inputvar </Item></Item>
		<Item name="mysql" tv="10192448">
			<Item name="命令大全" tv="10192784">&lt;span style=“font-size:18px;”&gt;  
  
MYSQL常用命令  
1.导出整个数据库  
mysqldump -u 用户名 -p –default-character-set=latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1)  
mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql  
2.导出一个表  
mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名  
mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql  
3.导出一个数据库结构  
mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql  
-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table  
4.导入数据库  
A:常用source 命令  
进入mysql数据库控制台，  
如mysql -u root -p  
mysql&gt;use 数据库  
然后使用source命令，后面参数为脚本文件(如这里用到的.sql)  
mysql&gt;source wcnc_db.sql  
B:使用mysqldump命令  
mysqldump -u username -p dbname &lt; filename.sql  
C:使用mysql命令  
mysql -u username -p -D dbname &lt; filename.sql  
一、启动与退出  
1、进入MySQL：启动MySQL Command Line Client（MySQL的DOS界面），直接输入安装时的密码即可。此时的提示符是：mysql&gt;  
2、退出MySQL：quit或exit  
二、库操作  
1、、创建数据库  
命令：create database &lt;数据库名&gt;  
例如：建立一个名为xhkdb的数据库  
mysql&gt; create database xhkdb;  
2、显示所有的数据库  
命令：show databases （注意：最后有个s）  
mysql&gt; show databases;  
3、删除数据库  
命令：drop database &lt;数据库名&gt;  
例如：删除名为 xhkdb的数据库  
mysql&gt; drop database xhkdb;  
4、连接数据库  
命令：use &lt;数据库名&gt;  
例如：如果xhkdb数据库存在，尝试存取它：  
mysql&gt; use xhkdb;  
屏幕提示：Database changed  
5、查看当前使用的数据库  
mysql&gt; select database();  
6、当前数据库包含的表信息：  
mysql&gt; show tables; （注意：最后有个s）  
三、表操作，操作之前应连接某个数据库  
1、建表  
命令：create table &lt;表名&gt; ( &lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]);  
mysql&gt; create table MyClass(  
&gt; id int(4) not null primary key auto_increment,  
&gt; name char(20) not null,  
&gt; sex int(4) not null default ’′,  
&gt; degree double(16,2));  
2、获取表结构  
命令：desc 表名，或者show columns from 表名  
mysql&gt;DESCRIBE MyClass  
mysql&gt; desc MyClass;  
mysql&gt; show columns from MyClass;  
3、删除表  
命令：drop table &lt;表名&gt;  
例如：删除表名为 MyClass 的表  
mysql&gt; drop table MyClass;  
4、插入数据  
命令：insert into &lt;表名&gt; [( &lt;字段名&gt;[,..&lt;字段名n &gt; ])] values ( 值 )[, ( 值n )]  
例如，往表 MyClass中插入二条记录, 这二条记录表示：编号为的名为Tom的成绩为.45, 编号为 的名为Joan 的成绩为.99，编号为 的名为Wang 的成绩为.5.  
mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59);  
5、查询表中的数据  
1)、查询所有行  
命令：select &lt;字段，字段，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;  
例如：查看表 MyClass 中所有数据  
mysql&gt; select  from MyClass;  
2）、查询前几行数据  
例如：查看表 MyClass 中前行数据  
mysql&gt; select  from MyClass order by id limit 0,2;  
或者：  
mysql&gt; select  from MyClass limit 0,2;  
6、删除表中数据  
命令：delete from 表名 where 表达式  
例如：删除表 MyClass中编号为 的记录  
mysql&gt; delete from MyClass where id=1;  
7、修改表中数据：update 表名 set 字段=新值,…where 条件  
mysql&gt; update MyClass set name=’Mary’where id=1;  
7、在表中增加字段：  
命令：alter table 表名 add字段 类型 其他;  
例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为  
mysql&gt; alter table MyClass add passtest int(4) default ’′  
8、更改表名：  
命令：rename table 原表名 to 新表名;  
例如：在表MyClass名字更改为YouClass  
mysql&gt; rename table MyClass to YouClass;  
更新字段内容  
update 表名 set 字段名 = 新内容  
update 表名 set 字段名 = replace(字段名,’旧内容’,’新内容’)  
  
  
  
  
  
  
  
文章前面加入个空格  
update article set content=concat(‘　　’,content);  
字段类型  
1．INT[(M)] 型：正常大小整数类型  
2．DOUBLE[(M,D)] [ZEROFILL] 型：正常大小(双精密)浮点数字类型  
3．DATE 日期类型：支持的范围是-01-01到-12-31。MySQL以YYYY-MM-DD格式来显示DATE值，但是允许你使用字符串或数字把值赋给DATE列  
4．CHAR(M) 型：定长字符串类型，当存储时，总是是用空格填满右边到指定的长度  
5．BLOB TEXT类型，最大长度为(2^16-1)个字符。  
6．VARCHAR型：变长字符串类型  
5.导入数据库表  
　　（）创建.sql文件  
　　（）先产生一个库如auction.c:mysqlbin&gt;mysqladmin -u root -p creat auction，会提示输入密码，然后成功创建。  
　　（）导入auction.sql文件  
　　c:mysqlbin&gt;mysql -u root -p auction &lt; auction.sql。  
　　通过以上操作，就可以创建了一个数据库auction以及其中的一个表auction。  
　　6．修改数据库  
　　（）在mysql的表中增加字段：  
　　alter table dbname add column userid int(11) not null primary key auto_increment;  
　　这样，就在表dbname中添加了一个字段userid，类型为int(11)。  
　　7．mysql数据库的授权  
　　mysql&gt;grant select,insert,delete,create,drop  
　　on . (或test./user./..)  
　　to 用户名@localhost  
　　identified by ‘密码’；  
　　如：新建一个用户帐号以便可以访问数据库，需要进行如下操作：  
　　mysql&gt; grant usage  
　　-&gt; ON test.  
　　-&gt; TO testuser@localhost;  
　　Query OK, 0 rows affected (0.15 sec)  
　　此后就创建了一个新用户叫：testuser，这个用户只能从localhost连接到数据库并可以连接到test 数据库。下一步，我们必须指定testuser这个用户可以执行哪些操作：  
　　mysql&gt; GRANT select, insert, delete,update  
　　-&gt; ON test.  
　　-&gt; TO testuser@localhost;  
　　Query OK, 0 rows affected (0.00 sec)  
　　此操作使testuser能够在每一个test数据库中的表执行SELECT，INSERT和DELETE以及UPDATE查询操作。现在我们结束操作并退出MySQL客户程序：  
　　mysql&gt; exit  
　　Bye9!  
1:使用SHOW语句找出在服务器上当前存在什么数据库：  
mysql&gt; SHOW DATABASES;  
2:2、创建一个数据库MYSQLDATA  
mysql&gt; Create DATABASE MYSQLDATA;  
3:选择你所创建的数据库  
mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！)  
4:查看现在的数据库中存在什么表  
mysql&gt; SHOW TABLES;  
5:创建一个数据库表  
mysql&gt; Create TABLE MYTABLE (name VARCHAR(20), sex CHAR(1));  
6:显示表的结构：  
mysql&gt; DESCRIBE MYTABLE;  
7:往表中加入记录  
mysql&gt; insert into MYTABLE values (“hyq”,”M”);  
8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）  
mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt”INTO TABLE MYTABLE;  
9:导入.sql文件命令（例如D:/mysql.sql）  
mysql&gt;use database;  
mysql&gt;source d:/mysql.sql;  
10:删除表  
mysql&gt;drop TABLE MYTABLE;  
11:清空表  
mysql&gt;delete from MYTABLE;  
12:更新表中数据  
mysql&gt;update MYTABLE set sex=”f”where name=’hyq’;  
以下是无意中在网络看到的使用MySql的管理心得,  
  
  
在windows中MySql以服务形式存在，在使用前应确保此服务已经启动，未启动可用net start mysql命令启动。而Linux中启动时可用“/etc/rc.d/init.d/mysqld start”命令，注意启动者应具有管理员权限。  
刚安装好的MySql包含一个含空密码的root帐户和一个匿名帐户，这是很大的安全隐患，对于一些重要的应用我们应将安全性尽可能提高，在这里应把匿名帐户删除、root帐户设置密码，可用如下命令进行：  
use mysql;  
delete from User where User=””;  
update User set Password=PASSWORD(‘newpassword’) where User=’root’;  
如果要对用户所用的登录终端进行限制，可以更新User表中相应用户的Host字段，在进行了以上更改后应重新启动数据库服务，此时登录时可用如下类似命令：  
mysql -uroot -p;  
mysql -uroot -pnewpassword;  </Item></Item>
		<Item name="重命名" tv="10193680">新名字</Item></Item>
	<Item name="@笔记" tv="10193008">
		<Item name="vscode" tv="10192336">
			<Item name="快捷键" tv="10193120">alt+m 主界面</Item></Item>
		<Item name="picgo" tv="10194800">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</Item>
		<Item name="git" tv="10194688">
			<Item name="删除所有内存重新提交" tv="10195136">run,https://blog.csdn.net/weixin_44049466/article/details/105426345</Item></Item></Item>
	<Item name="@软件" tv="10195360">
		<Item name="vnote" tv="10198960">run, G:\书籍\vnote_releases\vnote.exe</Item>
		<Item name="com dll查看" tv="10200864">run,G:\我的AHK程序\我的工程\com dll查看\Dll&amp;COM Viewer.exe</Item>
		<Item name="词典" tv="10201424">run,C:\Users\hetong\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\网易有道词典.lnk</Item>
		<Item name="音乐" tv="10199296">run,C:\ProgramData\Microsoft\Windows\Start Menu\Programs\网易云音乐.lnk</Item>
		<Item name="cherry笔记" tv="10201536">run,C:\Program Files\CherryTree\mingw64\bin\cherrytree.exe</Item>
		<Item name="搜索" tv="10198736">Run, Everything64.exe, F:\Everything 1.5a</Item>
		<Item name="tgp" tv="10201088">Run,*RunAs WeGame,E:\wegeme,</Item>
		<Item name="录制" tv="10199408">run,bdcam.exe,F:\Bandicam</Item>
		<Item name="百度网盘" tv="10200640">run,baidunetdisk.exe,F:\BaiduNetdisk</Item>
		<Item name="网易" tv="10199520">ikhlbilhuikhui</Item>
		<Item name="截图" tv="10197728">run,FSCapture.exe,C:\Program Files (x86)\FastStone Capture\
</Item>
		<Item name="秒表" tv="10198848">run,G:\我的AHK程序\脚本范例\ahkexample\各种脚本\其他合集\AHK 快餐店文中脚本\4.1-4.2计时器_闹钟 13秒表\13.秒表.ahk</Item>
		<Item name="gif录屏" tv="10198176">run,F:\gif\屏幕录制ScreenToGif 2.34.1.exe</Item>
		<Item name="画图可汗" tv="10200528">run,F:\绘图软件\SmoothDraw\SmoothDraw4.exe F:\绘图软件\模板.sddoc</Item>
		<Item name="正则表达式ahk" tv="10200976">run,C:\Users\kzf\Desktop\我的AHK程序\Adventure\Tools\Expressive\Expressive.ahk</Item>
		<Item name="正则表达式buddy" tv="10198512">run, F:\正则表达式\RegexBuddy4.9.exe</Item>
		<Item name="按键显示" tv="10198288">run,G:\我的AHK程序\我的工程\KeyPress-OSD-master（按键显示工具）\keycastow\keycastow.exe</Item>
		<Item name="vsvim" tv="10198400">run,https://blog.csdn.net/yanchezuo/article/details/78790961</Item></Item>
	<Item name="@ahk" tv="10199072">
		<Item name="帮助手册" tv="10200416">run,https://www.autoahk.com/help/autohotkey/zh-cn/docs/AutoHotkey.htm</Item>
		<Item name="屏幕亮度" tv="10200752">run,https://blog.csdn.net/vegata/article/details/7709332</Item>
		<Item name="帮助文档v2h" tv="10199632">run,https://hotkeyit.github.io/v2/docs/commands/ahkExecuteLine.htm</Item>
		<Item name="库目录" tv="10199184">run,https://github.com/HotKeyIt/awesome-AutoHotkey#memory</Item>
		<Item name="算法" tv="10198624">run,https://rosettacode.org/wiki/Category:AutoHotkey</Item>
		<Item name="开头设置" tv="10199744">#NoEnv
#KeyHistory 0
#MaxThreads 255
#MaxMem 4095
#MaxThreadsBuffer On
#MaxHotkeysPerInterval 99000000
#HotkeyInterval 99000000
#SingleInstance Force
ListLines Off
Process, Priority, , R
SetTitleMatchMode fast
SetBatchLines, -1
SetKeyDelay, -1, -1, -1
SetMouseDelay, -1
SetWinDelay, -1
SetControlDelay, -1
SetDefaultMouseSpeed, 0
CoordMode, ToolTip , Screen
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.</Item>
		<Item name="include库" tv="10199856">CommandText =
(%
#Include &lt;log4ahk&gt;
#Include &lt;my_lib&gt;
)
clipboard:=CommandText</Item>
		<Item name="字符串转双引号其他语言" tv="10199968">run,G:\我的AHK程序\我的工程\字符片段转延续片段\字符串转双引号.ahk</Item>
		<Item name="字符串转延续片段" tv="10200080">run,G:\我的AHK程序\我的工程\字符片段转延续片段\字符片段转延续片段.ahk</Item>
		<Item name="dialog" tv="10201200">c=
(%
Clipboard := c
TaskDialog(Clipboard, "", "", 0x1, 0)
TaskDialog(Instruction, Content := "", Title := "", Buttons := 1, IconID := 0, IconRes := "", Owner := 0x10010) {
	Local hModule, LoadLib, Ret
	
	If (IconRes != "") {
		hModule := DllCall("GetModuleHandle", "Str", IconRes, "Ptr")
		LoadLib := !hModule
            &amp;&amp; hModule := DllCall("LoadLibraryEx", "Str", IconRes, "UInt", 0, "UInt", 0x2, "Ptr")
	} Else {
		hModule := 0
		LoadLib := False
	}
	
	DllCall("TaskDialog"
        , "Ptr" , Owner        ; hWndParent
        , "Ptr" , hModule      ; hInstance
        , "Ptr" , &amp;Title       ; pszWindowTitle
        , "Ptr" , &amp;Instruction ; pszMainInstruction
        , "Ptr" , &amp;Content     ; pszContent
        , "Int" , Buttons      ; dwCommonButtons
        , "Ptr" , IconID       ; pszIcon
        , "Int*", Ret := 0)    ; *pnButton
	
	If (LoadLib) {
		DllCall("FreeLibrary", "Ptr", hModule)
	}
	
	Return {1: "OK", 2: "Cancel", 4: "Retry", 6: "Yes", 7: "No", 8: "Close"}[Ret]
}
)
Clipboard := c
TaskDialog(Clipboard, "", "", 0x1, 0)
TaskDialog(Instruction, Content := "", Title := "", Buttons := 1, IconID := 0, IconRes := "", Owner := 0x10010) {
	Local hModule, LoadLib, Ret
	
	If (IconRes != "") {
		hModule := DllCall("GetModuleHandle", "Str", IconRes, "Ptr")
		LoadLib := !hModule
            &amp;&amp; hModule := DllCall("LoadLibraryEx", "Str", IconRes, "UInt", 0, "UInt", 0x2, "Ptr")
	} Else {
		hModule := 0
		LoadLib := False
	}
	
	DllCall("TaskDialog"
        , "Ptr" , Owner        ; hWndParent
        , "Ptr" , hModule      ; hInstance
        , "Ptr" , &amp;Title       ; pszWindowTitle
        , "Ptr" , &amp;Instruction ; pszMainInstruction
        , "Ptr" , &amp;Content     ; pszContent
        , "Int" , Buttons      ; dwCommonButtons
        , "Ptr" , IconID       ; pszIcon
        , "Int*", Ret := 0)    ; *pnButton
	
	If (LoadLib) {
		DllCall("FreeLibrary", "Ptr", hModule)
	}
	
	Return {1: "OK", 2: "Cancel", 4: "Retry", 6: "Yes", 7: "No", 8: "Close"}[Ret]
}
</Item>
		<Item name="脚本库" tv="10201312">
			<Item name="json_feiyue_源码" tv="10200192">;------------------------------
;  JSon.ahk - v2.1  By FeiYue
;------------------------------


json_toobj(s)  ; JSon字符串转AHK对象
{
  static rep:=[ ["\\","\u005c"], ["\""",""""], ["\/","/"]
    , ["\r","`r"], ["\n","`n"], ["\t","`t"]
    , ["\b","`b"], ["\f","`f"] ]
  if !(p:=RegExMatch(s, "[\{\[]", r))
    return
  SetBatchLines, % (bch:=A_BatchLines)?"-1":"-1"
  stack:=[], obj:=arr:=[], is_arr:=(r="[")
  , key:=(is_arr ? 1:""), keyok:=0
  While p:=RegExMatch(s, "\S", r, p+StrLen(r))
  {
    if (r="{" or r="[")  ; 如果是 左括号
    {
      stack.Push(is_arr, arr), arr[key]:=[], arr:=arr[key]
      , is_arr:=(r="["), key:=(is_arr ? 1:""), keyok:=0
    }
    else if (r="}" or r="]")  ; 如果是 右括号
    {
      if !stack.Length()
        Break
      arr:=stack.Pop(), is_arr:=stack.Pop()
      , key:=(is_arr ? arr.Length():""), keyok:=0
    }
    else if (r=",")  ; 如果是 逗号
    {
      key:=(is_arr ? Floor(key)+1:""), keyok:=0
    }
    else if (r="""")  ; 如果是 双引号
    {
      if RegExMatch(s, """((?:[^""\\]|\\[\s\S])*)""", r, p)!=p
        Break
      if InStr(r1, "\")
      {
        For k,v in rep
          r1:=StrReplace(r1, v[1], v[2])
        v:="", k:=1
        While i:=RegExMatch(r1, "\\u[0-9A-Fa-f]{4}",, k)
          v.=SubStr(r1,k,i-k) . Chr("0x" SubStr(r1,i+2,4)), k:=i+6
        r1:=v . SubStr(r1,k)
      }
      if (!is_arr and keyok=0)
      {
        p+=StrLen(r)
        if RegExMatch(s, "\s*:", r, p)!=p
          Break
        key:=r1, keyok:=1
      }
      else arr[key]:=r1
    }
    else  ; 如果是 true、false、null、数字
    {
      if RegExMatch(s, "[\w\+\-\.]+", r, p)!=p
        Break
      arr[key]:=(r=="true" ? 1:r=="false" ? 0:r=="null" ? "":r+0)
    }
  }
  SetBatchLines, %bch%
  return obj
}

json_fromobj(obj, space:="")  ; AHK对象转JSon字符串
{
  ;-------------------
  ; 默认不替换 "/--&gt;\/" 与 特殊html字符&lt;、&gt;、&amp;
  ;-------------------
  static rep:=[ ["\\","\"], ["\""",""""]  ; , ["\/","/"]
    ; , ["\\u003c","&lt;"], ["\\u003e","&gt;"], ["\\u0026","&amp;"]
    , ["\r","`r"], ["\n","`n"], ["\t","`t"]
    , ["\b","`b"], ["\f","`f"] ]
  if !IsObject(obj)
  {
    if obj is Number  ; thanks lexikos
      return ([obj].GetCapacity(1) ? """" obj """" : obj)
    ;-------------------
    ; 布尔值在AHK中转为数字了
    ; if (obj=="true" or obj=="false" or obj=="null")
    ;   return obj
    ;-------------------
    For k,v in rep
      obj:=StrReplace(obj, v[2], v[1])
    ;-------------------
    ; 默认不替换 "Unicode字符--&gt;\uXXXX"
    ; While RegExMatch(obj, "[^\x20-\x7e]", k)
    ;   obj:=StrReplace(obj, k, Format("\u{:04x}",Ord(k)))
    ;-------------------
    return """" obj """"
  }
  is_arr:=1  ; 是简单数组
  For k,v in obj
    if (k!=A_Index) and !(is_arr:=0)
      Break
  s:="", space2:=space . "    ", f:=A_ThisFunc
  For k,v in obj
    s.= "`r`n" space2
    . (is_arr ? "" : """" Trim(%f%(k ""),"""") """: ")
    . %f%(v,space2) . ","
  return (is_arr?"[":"{") . Trim(s,",")
    . "`r`n" space . (is_arr?"]":"}")
}


s=
(

{
    "name": "BeJson",
    "url": "http://www.bejson.com",
    "page": 88,
    "page2": "88",
    "isNonProfit": true,
    "address": {
        "street": "科技园路",
        "city": "江苏苏州",
        "country": "中国"
    },
    "links": [
        {
            "name": "Google",
            "url": "http://www.google.com"
        },
        {
            "name": "Baidu",
            "url": "http://www.baidu.com"
        },
        {
            "name": "SoSo",
            "url": "http://www.SoSo.com"
        }
    ]
}

)</Item>
			<Item name="mcode机器码" tv="10200304">run,G:\我的AHK程序\我的工程\mcode机器码</Item>
			<Item name="多个tooltip v2" tv="10197840">class mtt 
{
    static s_tooltip_number := 1
    static s_max_btt := 40
    __New(txt := "btt", x := 0, y := 0, show_time := 999999999, BulitInStyleOrStyles := "", BulitInOptionOrOptions := "") 
    {
        this.timer := ObjBindMethod(this, "Tick")
        this.x := x
        this.BulitInStyleOrStyles := BulitInStyleOrStyles
        this.BulitInOptionOrOptions := BulitInOptionOrOptions
        this.y := y
        this.txt := txt
        this.show_time := show_time
        this.which := mtt.s_tooltip_number
        if(mtt.s_tooltip_number == mtt.s_max_btt)
        {
            mtt.s_tooltip_number := 0
        }
        mtt.s_tooltip_number++
        this.Start()
    }
    __Delete()
    {
    }
    Start() 
    {
        timer := this.timer
        SetTimer timer, -this.show_time
        ToolTip(this.txt, this.x, this.y, this.which)
    }
    Stop() 
    {
        try
        {
            timer := this.timer
            SetTimer timer, 0
            ToolTip(,,, this.which)
            this.timer := 0
        }
    }
    Tick() 
    {
        this.stop()
    }
}</Item>
			<Item name="文字提示gui" tv="10197952">;https://www.autohotkey.com/boards/viewtopic.php?f=83&amp;t=94044
#include &lt;log4ahk&gt;
#Requires AutoHotkey v2.0-
#SingleInstance
WiseGui( "Test"
       , "MainText:  Lorem ipsum"
       , "MainAlign: 0"
       , "SubText:   Sed ut perspiciatis unde`nomnis iste natus error sit voluptatem"
       , "SubAlign:  0"
       )
Sleep(2000)
WiseGui("Test") ; Kill

WiseGui("Test", "Theme: Info")
Sleep(2000)
WiseGui("Test") ; Kill

WiseGui("Test", "Theme: Success")
Sleep(2000)
WiseGui("Test") ; Kill

WiseGui("Test", "Theme: Error")
Sleep(2000)
WiseGui("Test") ; Kill

F2::WinExist("WiseGui\SplashClock ahk_class AutoHotkeyGUI") ? WinClose() : SplashClock()

SplashClock()
{
    WiseGui("SplashClock"
          , "FontMain:    s24 Norm,      Consolas"
          , "FontSub:     s48 Norm Bold, Consolas"
          , "MainText:" . FormatTime(A_Now, "ddd, dd-MMM-yyyy (") . FormatTime(A_Now, "YDay0") . ")"
          , "SubText:"  . FormatTime(A_Now, "hh:mm:ss tt")
          , "MainAlign:   0"
          , "SubAlign:    0"
          , "Margins:     4,4,2,0"
          , "Move:"                                        ; Center screen
          , "TextWidth:   420"
          , "Theme:       0x856442, 0xFFFFF0, 0xEBB800, 0" ; Same as Warning theme, but no Icon
          , "Show:        Fade@400ms"
          , "Hide:        Fade@400ms"
    )

    SetTimer( SplashClock, 900 )

    SplashClock()
    {
        If ( WinExist("WiseGui\SplashClock ahk_class AutoHotkeyGUI") )
             WiseGui("SplashClock", "SubText:" . FormatTime(A_Now, "hh:mm:ss tt"))
        Else SetTimer( , 0 )
    }
}

WiseGui(Name, Options*) ;  v0.96a by SKAN for ah2 on D48F/D491 @ autohotkey.com/r?t=94044   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  RM145
{ 
    If ( StrLen(Name) = 0 )
        Return

    Static Names := Map()
    Local  MyGui

    If ( Options.Length=0 &amp;&amp; Names.Has(Name) )
         Return GuiClose( Names[Name] )

    If ( Names.Has(Name) )
    {
        MyGui := Names[Name]
        UpdateGui(&amp;MyGui)
    }
    Else CreateGui(&amp;MyGui)



    ParseOptions(&amp;UsrOpts)  ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local Value
        For Value in Options
        {
            Switch( Type(Value) )
            {
                Case "String" :
                {
                    Value := StrSplit(Value, ["=", ":"], A_Space, 2)
                    If ( Value.Length &gt; 1 )
                         UsrOpts[ SubStr(Value[1], 1, 5) ] := Trim( Value[2], "'" . '"')
                }

                Case "Func", "BoundFunc" :
                {
                    UsrOpts["Trigger"] := Value
                }
            }
        }
    }


    UpdateGui(&amp;MyGui) ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local UsrOpts, Value, GuiP, Period

        UsrOpts := MyGui.UsrOpts
        If ( Options.Length )
             ParseOptions(&amp;UsrOpts)

        If ( UsrOpts.Has("Theme") )
        {
            GuiP :=  GetTheme( UsrOpts["Theme"] )
            MyGui.BackColor := GuiP["WindowColor"]
            MyGui["LineL"].Opt("Background" . GuiP["BorderColor"])
            MyGui["LineT"].Opt("Background" . GuiP["BorderColor"])
            MyGui["LineB"].Opt("Background" . GuiP["BorderColor"])
            MyGui["LineR"].Opt("Background" . GuiP["BorderColor"])
            MyGui["MainText"].Opt("c" . GuiP["TextColor"])
            MyGui["SubText" ].Opt("c" . GuiP["TextColor"])
            If MyGui["Icon"].Value
               MyGui["Icon"].Value := "HICON:" . GuiP["HICON"]
            WinRedraw(MyGui.Hwnd)
            MyGui.Show("NA")
        }

        If ( MyGui.UsrOpts.Has("MainT") )
        {
            If MyGui["MainText"].Text != UsrOpts["MainT"]
               MyGui["MainText"].Text := UsrOpts["MainT"]
            MyGui.UsrOpts.Delete("MainT")
        }

        If ( MyGui.UsrOpts.Has("SubTe") )
        {
            If MyGui["SubText"].Text != UsrOpts["SubTe"]
               MyGui["SubText"].Text := UsrOpts["SubTe"]
            MyGui.UsrOpts.Delete("SubTe")
        }

        OnClose(&amp;MyGui)
        ApplySettings(&amp;MyGui)

        If MyGui.UsrOpts.Has("Timer")
        {
            Period := 0 - Min(20000, Max(200, Format("{:d}", MyGui.UsrOpts["Timer"])))
            SetTimer( MyGui.MyTimer, Period )
            MyGui.UsrOpts.Delete("Timer")
        }
    }


    CreateGui(&amp;MyGui) ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local Value, Theme, GuiP, TxtP, UsrOpts, Font, Period, DHW, XY
        MyGui := Gui("+DpiScale -Caption +AlwaysOnTop +Owner +E0x08000000", "WiseGui\" . Name)
        Names[Name]       :=  MyGui
        MyGui.Name        :=  Name
        MyGui.MyTimer     :=  GuiClose.Bind(MyGui)
        MyGui.UsrOpts     :=  Map()

        UsrOpts           :=  MyGui.UsrOpts
        UsrOpts.CaseSense :=  "Off"

        If ( Options.Length )
             ParseOptions(&amp;UsrOpts)

        XY := UsrOpts.Has("Margi") ? StrSplit(UsrOpts["Margi"] . ",,,,", ",", A_Space, 5) : [2,1,0,0]
        Loop( 4 )
          XY[A_Index] := Format("{:d}", XY[A_Index]) * 4

        MyGui.MarginX    :=  0
        MyGui.MarginY    :=  0

        GuiP             :=  GetTheme( UsrOpts.Has("Theme") ? UsrOpts["Theme"] : "Info")
        MyGui.BackColor  :=  GuiP["WindowColor"]

        ; Icon
        If   GuiP["HICON"]
        {
             MyGui.Add("Text",    "x0 y0 w" . (XY[4]*2)+32 " h" (XY[4]*2)+32 . " vLineL Background" . GuiP["BorderColor"])
             MyGui.Add("Picture", "xp+" . XY[4] . " yp+" . XY[4] . " w32 h32 BackgroundTrans vIcon", "HICON:" . GuiP["HICON"])
             MyGui.Add("Text", "x+" . XY[4] . " w0 h0")
        }
        Else
        {
             MyGui.Add("Text",    "x0 y0   w1 h1 vLineL Background" . GuiP["BorderColor"])
             MyGui.Add("Picture", "xp yp w0 h0 vIcon")
        }

        MyGui.Add("Text", "x+0 ym w10 h1 Section vLineT Background" . GuiP["BorderColor"])

        ; MainText
        If (  UsrOpts.Has("MainT")  )
        {
              Value := UsrOpts["MainT"]
              MyGui.UsrOpts.Delete("MainT")
        }
        Else  Value := ["Warning", "Information", "Success", "Error", A_ScriptName][InStr("WISEU", GuiP["T"])]

        MyGui.MarginX   :=  XY[1]
        MyGui.MarginY   :=  XY[2]

        Font :=  UsrOpts.Has("FontM")  ?  StrSplit( UsrOpts["FontM"], ",", " ")  :  ["s10 Bold", "Segoe UI"]
        MyGui.SetFont( Font* )
        TxtP := "xp+" . MyGui.MarginX . " y+m vMainText BackgroundTrans c" . GuiP["TextColor"]
        TxtP .= UsrOpts.Has("TextW") ? ( " w" . UsrOpts["TextW"] ) : ""
        TxtP .= UsrOpts.Has("MainA") ? ( UsrOpts["MainA"]=0 ? " Center" : UsrOpts["MainA"]=1 ? " Right" : "" ) : ""

        If ( UsrOpts.Has("Main") &amp;&amp; UsrOpts["Main"]=0 )
             MyGui.Add("Text", "vMainText w0 h0 y+0 xp+" . MyGui.MarginX)
        Else MyGui.Add("Text", TxtP, Value)

        ; SubText
        If (  UsrOpts.Has("SubTe")  )
        {
              Value := UsrOpts["SubTe"]
              MyGui.UsrOpts.Delete("SubTe")
        }
        Else  Value := ""

        MyGui.MarginY   :=  XY[3]
        Font :=  UsrOpts.Has("FontS")  ?  StrSplit( UsrOpts["FontS"], ",", " ")  :  ["s10 Norm", "Segoe UI"]
        MyGui.SetFont( Font* )
        TxtP := "xp y+m vSubText BackgroundTrans c" . GuiP["TextColor"]
        TxtP .= UsrOpts.Has("TextW") ? " w" . UsrOpts["TextW"] : ""
        TxtP .= UsrOpts.Has("SubAl") ? ( UsrOpts["SubAl"]=0 ? " Center" : UsrOpts["SubAl"]=1 ? " Right" : "" ) : ""
        MyGui.Add("Text", TxtP, Value)

        MyGui.MarginY   :=  XY[2]
        ; Right / Bottom lines
        MyGui.Add("Text", "x+0 yp  w1  hp vLineR Background" . GuiP["BorderColor"])
        MyGui.Add("Text", "xs  y+m w10 h1 vLineB Background" . GuiP["BorderColor"])

        MyGui.MarginX   :=  XY[1]
        MyGui.MarginY   :=  0
        MyGui.Show("AutoSize Hide")
        Local X, Y, W, H, LX
        MyGui.GetPos(&amp;X, &amp;Y, &amp;W, &amp;H)

        MyGui["LineL"].Move(,,,H)
        MyGui["LineR"].Move(W-1,0,,H)
        MyGui["LineT"].GetPos(&amp;LX)
        MyGui["LineT"].Move(,,W-LX)
        MyGui["LineB"].Move(,H-1,W-LX)

        Local MW, SW
        MyGui["MainText"].GetPos(,,&amp;MW)
        MyGui["SubText" ].GetPos(,,&amp;SW)
        If ( MW &gt; SW )
             MyGui["SubText" ].Move(,,MW)
        Else MyGui["MainText"].Move(,,SW)

        MyGui.Add("Text", "x0 y0 w" . W . " h" . H . " vClick BackgroundTrans")

        If UsrOpts.Has("Shado") &amp;&amp; UsrOpts["Shado"]
        {
           dwOldLong := SetClassLong(MyGui.Hwnd, -26)           ; Save GCL_STYLE
           SetClassLong(MyGui.Hwnd, -26, dwOldLong | 0x20000)   ; Apply CS_DROPSHADOW
        }

        OnClose(&amp;MyGui)
        ApplySettings(&amp;MyGui, True)

        If UsrOpts.Has("Show")
           AnimateWindow( MyGui.Hwnd, UsrOpts["Show"] )

        MyGui.Show("NA")

        If UsrOpts.Has("Shado") &amp;&amp; UsrOpts["Shado"]
           SetClassLong(MyGui.Hwnd, -26, dwOldLong)             ; Restore GCL_STYLE


        If MyGui.UsrOpts.Has("Timer")
        {
            Period := 0 - Min(20000, Max(200, Format("{:d}", MyGui.UsrOpts["Timer"])))
            SetTimer( MyGui.MyTimer, Period )
            MyGui.UsrOpts.Delete("Timer")
        }
    }


    ApplySettings(&amp;MyGui, Create:=0)
    {
        Local UsrOpts := MyGui.UsrOpts
        If UsrOpts.Has("WMP")
        {
            PlaySound( Name, UsrOpts["WMP"] )
            Sleep(100)
            MyGui.UsrOpts.Delete("WMP")
        }

        If ( UsrOpts.Has("Move") )
        {
            GuiSetPos( MyGui.Hwnd, StrSplit( UsrOpts["Move"], ",", A_Space, 3)* )
            MyGui.UsrOpts.Delete("Move")
        }
        Else
        If ( Create = True )
        {
            GuiSetPos( MyGui.Hwnd, "-10", "-10" )
        }

        Local Trans, DHW
        If ( MyGui.UsrOpts.Has("Trans") )
        {
             Trans :=  Min(255, Max(64, Format("{:d}", MyGui.UsrOpts["Trans"])))
             DHW   :=  A_DetectHiddenWindows
             DetectHiddenWindows(True)
             WinSetTransparent(Trans, MyGui.Hwnd)
             DetectHiddenWindows(DHW)
        }
    }


    GetTheme(Theme)   ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        If ( Not InStr(Theme, ",") )
        {
             Theme := Format( "{:U}", SubStr(Theme, 1,1) )
             Return ( Theme="W" ?  Map( "T","W",  "TextColor","856442", "WindowColor","FFFFF0", "BorderColor","EBB800",  "HICON",GetIcon(Theme) )
                    : Theme="I" ?  Map( "T","I",  "TextColor","194499", "WindowColor","F0F8FF", "BorderColor","3399FF",  "HICON",GetIcon(Theme) )
                    : Theme="S" ?  Map( "T","S",  "TextColor","155724", "WindowColor","F0FFE9", "BorderColor","429300",  "HICON",GetIcon(Theme) )
                    : Theme="E" ?  Map( "T","E",  "TextColor","721C24", "WindowColor","FFF4F4", "BorderColor","E40000",  "HICON",GetIcon(Theme) )
                                :  Map( "T","I",  "TextColor","194499", "WindowColor","F0F8FF", "BorderColor","3399FF",  "HICON",GetIcon("I") ) )
        }

        Local Arr := StrSplit(Theme . ",,,,", ",", A_Space, 5)
        Return Map( "T","U"
                  , "TextColor",    StrLen( Arr[1] ) ? Format( "{:06X}", Arr[1] ) : GetSysColor( 8)
                  , "WindowColor",  StrLen( Arr[2] ) ? Format( "{:06X}", Arr[2] ) : GetSysColor(15)
                  , "BorderColor",  StrLen( Arr[3] ) ? Format( "{:06X}", Arr[3] ) : GetSysColor( 6)
                  , "HICON",        StrLen( Arr[4] ) = 0 ? GetIcon("") : Arr[4] )
    }


    GetSysColor(nIndex)  ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Return Format("{5:}{6:}{3:}{4:}{1:}{2:}", StrSplit(Format("{:06X}", DllCall("User32.dll\GetSysColor", "Int",nIndex)))*)
    }


    GetIcon(Theme, W:=0, H:=0)    ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    { ; v1.10
        Local B64, B64Len, nBytes, Bin

        B64 := ( Theme="W" ? "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAXVBMVEXruAD//+KFZEL13HH+/NiPclLsuwr9+c789cH887v46Jj45pP02GbtvhPEt5"
        . "ruwh/67ar67amii22Zf2Dyz0rxz0nb1LfUyq7MwaSzooTuwiD499rx7tHn4sWrl3l1GphJAAABHUlEQVRYw+2WybLCIBBF3wUyCZmMUfMc/v8zLXeaC0IXW86+T9FAD3+FQiH"
        . "Gv7NTa0w7WTfKo3vd4YNO96LwWhvsMLpOjz818NCsqfEaAXTa8Q8IckhJ4zOeDdLzy7M4IcIauYDv+38qpa67t6glCVQkiCTRGxY8dgLT/zwAC+6Se+xYUGFP96P+wIIFRLg2"
        . "nUewgXBBgfUIBhA2KJg8giuIOShoPYIziDYoMB7BA4QRCW4CAadwVBUkKUwsWCC5RMuCIxib/pGeagPj0r/yZbiAGZOLyU8na4iMTm8oZ6WWO7ihJB9hUZ5i0oKmWnkETS1o6"
        . "5viYlolg+U20DPq3NGWPVwzx3vugpG74uQuWWJGZ+f3mje/17xCoRDhBWODDIHAQPWnAAAAAElFTkSuQmCC" : Theme="I" ? "iVBORw0KGgoAAAANSUhEUgAAAEAAAABAC"
        . "AMAAACdt4HsAAAAVFBMVEUzmf/w+P8ZRJmSyf/o9P/c5vOks9Pg8P/V6v/P6P/B4f+y2f+u1v+IxP9wuP9Npv9Eof88nv9tg7jH0ue7yOA6nf80VqFKZqmRosrR3O18kL9cdb"
        . "Au8FSxAAABHElEQVRYw+2WyZaEIAxFO4JhKMSpyp7+/z9bdzYRk2xqxd2/e+AkIXw0Gg2OcUjRW+tjGkZ9ejIBTgQzqeKzsVBgzSzPZwcXuCzNG6hgRPHXA6o8XgLBvzwxKM/"
        . "f/3bdortFhjNf3c4TzmSmfo4TuFlTANzzm1WUYir7BxH7sqMm+QH03RAkgnAzfyCiPpuDTDBUBQkKfkgVD1JVEKFguxTEqsBDQbfzTQS+KrBXgp4IrFjQHwJQCPyF4BMUV4gy"
        . "QbwpIxUsVJDEjbQSAdNIo0wwMsPECQIzzqzAMA8KJ7C3S86QKmy67TI70onrE5E8qnUymYWimbJqsSxHfENyAfFq6xFxFa82/XLVr/d3fTD0Xxz9J0v/zWs0Ggx/07kMr8YqP"
        . "fYAAAAASUVORK5CYII=" : Theme="S" ? "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAY1BMVEVCkwDw/+kVVySZyXXo+t/c7dbh9tTS7MHF5K+325yz2"
        . "ZiQxGl6tktRnBRKmAvG28Jrj24yZzujvaHm9uBaoiDR5MzX78fW78avx62WspWJp4lbg19IdU5IlwlboiG70bd7m3xysmd2AAABTUlEQVRYw+2W226EIBCGOwMqKyqeD6tr+/"
        . "5PWeO2oSjEsdzyJV5o8v+ZgzDzEQgErlhlKnrOe5HK9r46Zwn8IWH5LXnBOBzgrKDrsxgsxBlVz8ABI8lfD3DyeBEMtN7m4BE/MYsMLsgu+heDFTWVXz+9KP6TwIiIMyWJnIO"
        . "NqEKsInjD8/sBlIhYk+qYOBMo9Wvi1q9go6kQMQKN+2xKsFEbCWxIp0FqreCmX4wvqdNAgIUnIn4aX4TToHcEUILB4DTgjgAUGHCSQaQDeIIJJ6TQLVh1vy2IwGQgFHFCfDtU"
        . "5wBAENrYzIg4NzDqClDaKMF0mKDULaD8SOvhBGK9PSMcaWmHSeHOctIn1OM87QY1HGHkC2VBo4f6QqGGoNBWQnbjUu2Uak4DrvC91n0Hi+9o8x6uvuPdf8HwX3H8lyw6rUzFw"
        . "Pmwr3mBQOCCb5bODse1hzUgAAAAAElFTkSuQmCC" : Theme="E" ? "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAS1BMVEXkAAD/7u1yHCTyd3eziovFo"
        . "6T+5OPlCgqfbW/92dj7y8v6xcT4s7LOr6/2m5rwa2voISHmFRT2oJ/tTU3tTUy8l5ipfH6UXWD2oaDGo2xeAAABGUlEQVRYw+2W3W7DIAyFdyCB8VMIdN32/k+6SZ3SZBSbyr"
        . "d8d1F0TmxiG79NJhOOLafojfEx5e11ddEBB4IuL8mtNviH0XZcf3V4gvsY1Wt00GPhV3SpI2l8g6AK4h/M4goG5iStA4OzfAKCJMqjfpYLjqzrXlFlKIBFqctRr9Q6EkI4CP4"
        . "c2sdA9B923pV6fPSmfln2d/3ezHjqsJz1yF2DhNah1SN1DSJah1aP2DXwaB2+Gj1818DgzKe6c8MJM2yARd3TGDXwtAGfQqRT4A8xjR1ioguJ/42ZLmW+kDaymfhSDlQ7t/rW"
        . "QZMDhW9nU8iRxg8UzQxVbqQ5Kx3r4ouFpYKgii9X4fUuXTCkK45wyRKueZPJhOEHEsMMXLgJ8a8AAAAASUVORK5CYII=" : "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYA"
        . "AAAfFcSJAAAADUlEQVQImWOor69nBgAEfwGBGWiMoAAAAABJRU5ErkJggg==" )

        nBytes :=  Floor((B64Len := StrLen(B64 := RTrim(B64,"=")))*3/4)
        Bin    :=  Buffer(nBytes)

        DllCall("Crypt32.dll\CryptStringToBinary", "str",B64, "int",B64Len, "int",1, "ptr",Bin,"uintp",nBytes, "Int",0, "Int",0)
        Return DllCall("User32.dll\CreateIconFromResourceEx", "ptr",Bin, "int",nBytes, "int",1, "int",0x30000, "Int",W, "Int",H, "Int",0, "ptr")
    }


    PlaySound(Name, Filename:="")    ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {                                ; by SKAN for ah2 on D48J/D48K @ autohotkey.com/r?t=93918
        Static Names := Map()

        If ( Filename="" )
        {
            If Names.Has(Name)
            {
                Names[Name].Controls.Stop
              , Names.Delete(Name)
            }
            Return
        }

        Names[Name]     :=  ComObject("WMPlayer.OCX")
      , Names[Name].Url :=  FileName

        While( Names.Has(Name)
           &amp;&amp;  Names[Name].controls.isAvailable("stop")
           &amp;&amp; !Names[Name].controls.currentPosition )
               Sleep 10

        Try SetTimer(CheckSound.Bind(Name), 2000)

        CheckSound(_Name)
        {
            If ( Not Names.Has(_Name) )
                 Return SetTimer(, 0)

            If ( Names[_Name].playState != 3 )
            {
                 SetTimer(, 0)
               , Names.Delete(_Name)
            }
        }
    }


    SetClassLong(Hwnd, nIndex, dwNewLong:="")
    {
        If ! IsInteger(dwNewLong)
             Return A_PtrSize=8  ? DllCall("User32.dll\GetClassLongPtr", "ptr",Hwnd, "int",nIndex, "uint")
                                 : DllCall("User32.dll\GetClassLong",    "ptr",Hwnd, "int",nIndex, "uint")

        Else Return A_PtrSize=8  ? DllCall("User32.dll\SetClassLongPtr", "ptr",Hwnd, "int",nIndex, "ptr",dwNewLong, "uint")
                                 : DllCall("User32.dll\SetClassLong",    "ptr",Hwnd, "int",nIndex, "ptr",dwNewLong, "uint")
    }


    GuiSetPos(Hwnd, X:="", Y:="", M:="")   ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local DPI_AWARENESS_CONTEXT_UNAWARE, DPI_AWARENESS_CONTEXT := 0

        Try
        {
            DPI_AWARENESS_CONTEXT         := DllCall("User32.dll\GetThreadDpiAwarenessContext", "ptr")
            DPI_AWARENESS_CONTEXT_UNAWARE := DPI_AWARENESS_CONTEXT - 1
            DllCall("User32.dll\SetThreadDpiAwarenessContext", "ptr",DPI_AWARENESS_CONTEXT_UNAWARE, "ptr")
        }

        Local Err, mLeft, mTop, mRight, mBottom
        Try M := MonitorGetWorkArea(M,  &amp;mLeft, &amp;mTop, &amp;mRight, &amp;mBottom)
        Catch Error as Err
            M := MonitorGetWorkArea("", &amp;mLeft, &amp;mTop, &amp;mRight, &amp;mBottom)

        Local RECT := Buffer(16, 0)
        DllCall("User32.dll\GetWindowRect", "ptr",Hwnd, "ptr",RECT)
        Local W := NumGet(RECT,  8, "int") - NumGet(RECT, 0, "int")
        Local H := NumGet(RECT, 12, "int") - NumGet(RECT, 4, "int")

        X := mLeft + (StrLen(X)=0 ? ( (mRight  - mLeft)//2 ) - (W//2) : X&lt;0 ? mRight  - mLeft - W + 1 + X : X)
        Y := mTop  + (StrLen(Y)=0 ? ( (mBottom - mTop )//2 ) - (H//2) : Y&lt;0 ? mBottom - mTop  - H + 1 + Y : Y)

        DllCall("User32.dll\MoveWindow", "ptr",Hwnd, "int",X, "int",Y, "int",W, "int",H, "int",1)
        If ( DPI_AWARENESS_CONTEXT )
             DllCall("User32.dll\SetThreadDpiAwarenessContext", "ptr",DPI_AWARENESS_CONTEXT)
    }


    AnimateWindow(Hwnd, P)  ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local Flags := Map()
        Flags.CaseSense := "Off"
        Flags.Set("Fade",      "0x00080000",    "Zoom",           "0x00000010"
                , "SlideEast", "0x00040001",    "SlideNorthEast", "0x00040009",    "SlideNorth", "0x00040008",    "SlideNorthWest", "0x0004000A"
                , "SlideWest", "0x00040002",    "SlideSouthWest", "0x00040006",    "SlideSouth", "0x00040004",    "SlideSouthEast", "0x00040005"
                , "RollEast",  "0x00000001",    "RollNorthEast",  "0x00000009",    "RollNorth",  "0x00000008",    "RollNorthWest",  "0x0000000A"
                , "RollWest",  "0x00000002",    "RollSouthWest",  "0x00000006",    "RollSouth",  "0x00000004",    "RollSouthEast",  "0x00000005")

        P    :=  StrSplit(P, ["@", "ms"], "- ")
        P[1] :=  Flags.Has(P[1]) ? Flags[P[1]] : Flags["Fade"]
        P[1] |=  DllCall("User32.dll\IsWindowVisible", "ptr",Hwnd) ? 0x10000 : 0
        P[2] :=  Min(2500, Max(25, Format("{:d}", P[2])))


        DllCall("User32.dll\AnimateWindow", "ptr",Hwnd, "int",P[2], "int",P[1] )
    }


    OnClose(&amp;MyGui)   ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        Local UsrOpts := MyGui.UsrOpts
        If ( UsrOpts.Has("Close") )
        {
             If ( UsrOpts["Close"] )
                  MyGui["Click"].OnEvent("Click", GuiClose.Bind(MyGui, True))
        }
        Else
        {
             MyGui["Click"].OnEvent("Click", GuiClose.Bind(MyGui, True))
             UsrOpts["Close"] := 1
        }

        MyGui.OnEvent("Close",  (*) =&gt; GuiClose(MyGui, "*"))
        MyGui.OnEvent("ContextMenu",  (*) =&gt; GuiClose(MyGui, "-1"))
    }


    GuiClose(thisGui, Clicked:="0", *)  ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    {
        SetTimer(thisGui.MyTimer, 0)

        If ( ! thisGui.UsrOpts["Close"] )
        {
            Sleep(0)
            Return 1
        }

        Local err
        Try thisGui.Title := ""
        Catch Error as err
            Return

        Names.Delete(thisGui.Name)

        If thisGui.UsrOpts.Has("Hide")
           AnimateWindow( ThisGui.Hwnd, thisGui.UsrOpts["Hide"] )

        SetTimer( PlaySound.Bind(thisGui.Name), -1 )

        If thisGui.UsrOpts.Has("Close")
        If thisGui.UsrOpts["Close"] = "Trigger"
        If thisGui.UsrOpts.Has("Trigger")
           SetTimer( thisGui.UsrOpts["Trigger"].Bind(Clicked), -1)

        thisGui.Destroy()
    }
}   ; -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -</Item>
			<Item name="获取光标位置" tv="10198064">GetCaretPos(Byacc:=1)
{
	Static init
    If (A_CaretX=""){
		Caretx:=Carety:=CaretH:=CaretW:=0
		If (Byacc){
			If (!init)
				init:=DllCall("LoadLibrary","Str","oleacc","Ptr")
			VarSetCapacity(IID,16), idObject:=OBJID_CARET:=0xFFFFFFF8
			, NumPut(idObject==0xFFFFFFF0?0x0000000000020400:0x11CF3C3D618736E0, IID, "Int64")
			, NumPut(idObject==0xFFFFFFF0?0x46000000000000C0:0x719B3800AA000C81, IID, 8, "Int64")
			If (DllCall("oleacc\AccessibleObjectFromWindow", "Ptr",Hwnd:=WinExist("A"), "UInt",idObject, "Ptr",&amp;IID, "Ptr*",pacc)=0){
				Acc:=ComObject(9,pacc,1), ObjAddRef(pacc)
				Try Acc.accLocation(ComObj(0x4003,&amp;x:=0), ComObj(0x4003,&amp;y:=0), ComObj(0x4003,&amp;w:=0), ComObj(0x4003,&amp;h:=0), ChildId:=0)
				, CaretX:=NumGet(x,0,"int"), CaretY:=NumGet(y,0,"int"), CaretH:=NumGet(h,0,"int")
			}
		}
		If (Caretx=0&amp;&amp;Carety=0){
			MouseGetPos, x, y
            ;x := 0, y := 0
			Return {x:x,y:y,h:30,t:"Mouse",Hwnd:Hwnd}
		} Else
        	Return {x:Caretx,y:Carety,h:Max(Careth,30),t:"Acc",Hwnd:Hwnd}
    } Else
        Return {x:A_CaretX,y:A_CaretY,h:30,t:"Caret",Hwnd:Hwnd}
}</Item>
			<Item name="vscode调试launch" tv="10205584">{
    "configurations": [
        {
            "name": "AutoHotkey Debug U64",
            "runtimeArgs": [
                "/CP65001",
                "/ErrorStdOut",
            ],
            "program": "${file}",
            "request": "launch",
            "runtime_v1": "C:/Program Files/AutoHotkey/AutoHotkey.exe",
            "runtime_v2": "C:/Program Files/AutoHotkey_V2/AutoHotkey64.exe",
            "type": "autohotkey",
            "port": "9002-9010",
            "console": "internalConsole",
            "useOutputDebug": {
                "useTrailingLinebreak": true
            },
            "useAutoJumpToError": true,
            "usePerfTips": {
                "fontColor": "red",
                "format": "{{elapsedTime_ms}} ms {{hitCount}} hit"
            },
            "useDebugDirective": true
        },
        {
            "name": "AutoHotkey Debug U32",
            "runtimeArgs": [
                "/CP65001",
                "/ErrorStdOut"
            ],
            "program": "${file}",
            "request": "launch",
            "runtime_v1": "D:/AutoHotkey/AutoHotkey32.exe",
            "runtime_v2": "D:/AutoHotkey2/AutoHotkey32.exe",
            "type": "autohotkey",
            "port": "9002-9010",
            "useOutputDebug": {
                "useTrailingLinebreak": true
            },
            "useAutoJumpToError": true,
            "usePerfTips": {
                "fontColor": "red",
                "format": "{{elapsedTime_ms}} ms {{hitCount}} hit"
            },
            "useDebugDirective": true
        }
    ]
}</Item>
			<Item name="数字区间正则" tv="10206144">gen(a, b, q := '') {
    if !q {
        if a &gt; b
            t := a, a := b, b := a
        a := String(Integer(a))
        b := String(Integer(b))
    }
    la := StrLen(a), lb := StrLen(b), s := ''
    if (la &lt; lb) {
        loop (t := '', la)
            t .= '9'
        return gen(a, t, q) '|' gen('' t + 1, b, q)
    } else if (la == 1)
        return q (a == b ? a : a = '0' &amp;&amp; b = '9' ? '\d' : '[' a '-' b ']')
    else {
        sa := SubStr(a, 1, 1) + 0, sb := SubStr(b, 1, 1) + 0
        ua := SubStr(a, 2) + 0 ? sa + 1 : sa
        if (sa == sb)
            return gen(SubStr(a, 2), SubStr(b, 2), q sa)
        else if (ua &lt; sb) {
            if ua &amp;&amp; !(a ~= '^[1-9]0*$')
                s := gen(a, Format('{:0' la 'd}', ua * (10 ** (la - 1)) - 1), q)
            if (b ~= '^9+$')
                s .= '|' q (ua = 9 ? '9' : '[' ua '-9]') (lb &gt; 2 ? '\d{' (lb - 1) '}' : '\d')
            else {
                db := sb - 1
                s .= '|' q (db == ua ? ua : ua = '0' &amp;&amp; db = '9' ? '\d' : '[' ua '-' db ']') '\d' (lb &gt; 2 ? '{' (lb - 1) '}' : '')
                s .= SubStr(b, 2) + 0 ? '|' gen(Format('{:0' lb 'd}', sb * (10 ** (lb - 1))), b, q) : '|' q b
            }
        } else {
            if ua
                s .= '|' gen(a, Format('{:0' la 'd}', ua * (10 ** (la - 1)) - 1), q)
            s .= SubStr(b, 2) + 0 ? '|' gen(Format('{:0' lb 'd}', sb * (10 ** (lb - 1))), b, q) : '|' q b
        }
    }
    return LTrim(s, '|')
}</Item>
			<Item name="数字区间转正则v1" tv="10204352">gen(a, b, q := "") {
    if !q {
        if a &gt; b
            t := a, a := b, b := a
        a := Format("{:d}", a)
        b := Format("{:d}", b)
    }
    la := StrLen(a), lb := StrLen(b), s := ""
    if (la &lt; lb) {
        t := ""
        loop,% la
            t .= "9"
        s := gen(a, t, q)
        return s "|" gen("" t + 1, b, q)
    } else if (la == 1) {
        return q (a == b ? a : a = "0" &amp;&amp; b = "9" ? "\d" : "[" a "-" b "]")
    } else {
        sa := SubStr(a, 1, 1) + 0, sb := SubStr(b, 1, 1) + 0
        ua := SubStr(a, 2) + 0 ? sa + 1 : sa
        if (sa == sb) {
            return gen(SubStr(a, 2), SubStr(b, 2), q sa)
        } else if (ua &lt; sb) {
            if ua &amp;&amp; !(a ~= "^10*$")
                s .= "|" gen(a, "" ua * (10 ** (la - 1)) - 1, q)
            if (b ~= "^9+$")
                s .= "|" q (ua = 9 ? "9" : "[" ua "-9]") (lb &gt; 2 ? "\d{" (lb - 1) "}" : "\d")
            else {
                db := sb - 1
                s .= "|" q (db == ua ? ua : ua = "0" &amp;&amp; db = "9" ? "\d" : "[" ua "-" db "]") "\d" (lb &gt; 2 ? "{" (lb - 1) "}" : "")
                s .= SubStr(b, 2) + 0 ? "|" gen("" sb * (10 ** (lb - 1)), b, q) : "|" q b
            }
        } else if (ua == sb) {
            if ua
                s .= "|" gen(a, "" ua * (10 ** (la - 1)) - 1, q)
            s .= SubStr(b, 2) + 0 ? "|" gen("" sb * (10 ** (lb - 1)), b, q) : "|" q b
        } else {

        }
    }
    return LTrim(s, "|")
}</Item>
			<Item name="内存编码" tv="10207376">#include &lt;log4ahk&gt;
#include &lt;log4ahk&gt;
BufGet(Ptr, Bytes)
{
    Local Buf :=  Buffer(Bytes)
    Try DllCall("Kernel32\RtlMoveMemory", "ptr",Buf, "ptr",Ptr, "ptr",Bytes)
    Return Buf
}
Bin  :=  BufGet( StrPtr("abc"), 40 )
ListBuffer(&amp;Bin)

ListBuffer(&amp;Bin, Title := "", *)                            ; v0.28 by SKAN for ah2 on D52L/D533 @ autohotkey.com/r?t=101121
{
    Static hMod1,  hMod2,  hMod3

    hMod1  :=  DllCall("Kernel32\LoadLibrary", "str","RichEd20.dll", "ptr")
    hMod2  :=  DllCall("Kernel32\LoadLibrary", "str","Shlwapi.dll",  "ptr")
    hMod3  :=  DllCall("Kernel32\LoadLibrary", "str","Crypt32.dll",  "ptr")

    Local  Loading        :=  True
        ,  ReverseSearch  :=  0
        ,  Bytes          :=  0
        ,  TickCount      :=  A_TickCount

    Local  MyGui
        ,  ChkB1,  ChkB2
        ,  Edit1,  Edit2,  Edit3
        ,  UpDn1
        ,  Text1,  Text2,  Text3
        ,  Rich1
        ,  Push1
        ,  MySB

    MyGui   :=   Gui("+DpiScale +AlwaysOnTop", "ListBuffer" . (Strlen(Title) ? " - " : "") . Title)
                 MyGui.MarginX  :=  20
                 MyGui.MarginY  :=  16

                    GetSysColor(n)
                    {
                        Return  Format( "{5:}{6:}{3:}{4:}{1:}{2:}", StrSplit(Format("{:06X}"
                                      , DllCall("User32\GetSysColor", "int",n)))* )
                    }

    Local  ColorOption := "c" GetSysColor(8) " Background" GetSysColor(5)
        ,  X, Y, W,  BigE := 0

                 MyGui.SetFont("s11", "Courier New")
    Edit1   :=   MyGui.AddEdit("xm ym 0x200000 R4 +ReadOnly -Tabstop " ColorOption, Format("{:48}",""))
                 Edit1.GetPos(,,&amp;W)
                 Edit1.Text  :=  ""

                 MyGui.SetFont("s10", "Segoe UI")
                 MyGui.AddText("xm y8", "Offset")
                 MyGui.AddText("x160 yp w80", "Search")
    ChkB1   :=   MyGui.AddCheckbox("x240 yp -Tabstop Right w" w - 240 + MyGui.MarginX, "&amp;Reverse")
                 ChkB1.OnEvent("Click", (*) =&gt; ReverseSearch := not ReverseSearch)

    Push1   :=   MyGui.AddButton("x+0 yp w0 hp -Tabstop Default", "&amp;Go")
                 Push1.OnEvent("Click", Search)

                 MyGui.SetFont("s11", "Consolas")
    Edit2   :=   MyGui.AddEdit("xm y+4 w124 Number Right", 0)
                 Edit2.OnEvent("Change", SelectByte)

    UpDn1   :=   MyGui.AddUpDown("Left Wrap 0x80 Range0-" Bin.Size-1)
    Edit3   :=   MyGui.AddEdit("x160 yp vSearch w" w - 160 + MyGui.MarginX)

                 MyGui.SetFont("s10", "Segoe UI")
    Text1   :=   MyGui.AddText("xm y+8", "Hex " Bin.Size " bytes")
    Text2   :=   MyGui.AddText("x160 yp Right w" w - 160 + MyGui.MarginX, (A_PtrSize=8 ? "x64" : "x86") " @ " Bin.Ptr)

    Local  CHARRANGE
        ,  Rich1_Min     :=  0
        ,  Rich1_Max     :=  0
        ,  Rich1_Options :=  ( 0x200000    ;  WS_VSCROLL
                             | 0x000100    ;  ES_NOHIDESEL
                             | 0x000800    ;  ES_READONLY
                             | 0x008000 )  ;  ES_SAVESEL
                          .  " E0x20000 "  ;  WS_EX_STATICEDGE
                          .  " w" W

                 MyGui.SetFont("s11", "Courier New")
    Rich1   :=   MyGui.AddCustom("ClassRichEdit20A xm y+4 R8 " Rich1_Options)
                 RichEdit_SetPropertyBits(Rich1.Hwnd)
                 DllCall("User32\ShowScrollBar", "ptr",Rich1.Hwnd, "int",1, "int",True) ; SB_VERT 1

                 MyGui.SetFont("s10", "Segoe UI")
                 MyGui.AddText("xm y+8", "Text")
                 MyGui.SetFont("s11", "Courier New")
                 MyGui.AddText("r5 y+4 Center E0x20000 w" W)
    Text3   :=   MyGui.AddText("xp+16 yp+8 r4 w" W-20)

    Local  EditMargins  :=  Format("0x{1:04X}{1:04X}", 8*(A_ScreenDPI/96))

                 SendMessage(0xD3, 0x3, EditMargins, Edit1.Hwnd)                 ;  EM_SETMARGINS 0xD3
                 SendMessage(0xD3, 0x3, EditMargins, Edit2.Hwnd)
                 SendMessage(0xD3, 0x3, EditMargins, Edit3.Hwnd)
                 SendMessage(0xD3, 0x3, EditMargins, Rich1.Hwnd)

                 MyGui.SetFont("s10", "Segoe UI")
                 MyGui.AddText("xm y+16", "Values")
    ChkB2   :=   MyGui.AddCheckbox("x160 yp -Tabstop Right w" w - 160 + MyGui.MarginX, "&amp;BigEndian")
                 ChkB2.OnEvent("Click", ToggleEndian)

    MyGui.AddText("xm y+4 w0 h0").GetPos(&amp;X, &amp;Y)
    MyGui.AddButton("xp yp wp hp -Tabstop", "&amp;Values").OnEvent("Click", (*) =&gt; Edit1.Focus())
    MyGui.AddButton("xp yp wp hp -Tabstop", "&amp;Offset").OnEvent("Click", (*) =&gt; Edit2.Focus())
    MyGui.AddButton("xp yp wp hp -Tabstop", "&amp;Search").OnEvent("Click", (*) =&gt; Edit3.Focus())
    MyGui.AddButton("xp yp wp hp -Tabstop", "&amp;Hex"   ).OnEvent("Click", (*) =&gt; Rich1.Focus())
    Edit1.Move(X, Y)

    MySB    :=   MyGui.AddStatusBar()
                 MySB.SetParts(MyGui.MarginX, W, MyGui.MarginX)

    Local  Hex  :=  BufferToSHex(&amp;Bin)

                    GuiClose(*)
                    {
                        If  Loading
                            Return 0

                        MyGui.Destroy()
                        hMod1 := not  DllCall("Kernel32\FreeLibrary", "ptr",hMod1)
                        hMod2 := not  DllCall("Kernel32\FreeLibrary", "ptr",hMod2)
                        hMod2 := not  DllCall("Kernel32\FreeLibrary", "ptr",hMod3)
                        Return
                    }

    MyGui.OnEvent("Close",  GuiClose)
    MyGui.OnEvent("Escape", GuiClose)

    MyGui.Show("AutoSize Hide")
    MyGui.Show()

                    MySB_Tip(Text, TimeOut := 2000)
                    {
                        Try MySB.SetText(RTrim( A_Space Text, A_Space), 2)
                        If  TimeOut
                            SetTimer((*) =&gt; MySB_Tip("", 0), 0 - Abs(Timeout))
                    }

    MySB_Tip("Loading ..", 0)
    DllCall("User32\SetWindowTextA", "ptr",Rich1.Hwnd, "ptr",Hex)

    SendMessage(0xB1, Hex.Size, Hex.Size, Rich1.Hwnd)                            ;  EM_SETSEL
    SendMessage(0x445, 0, 0x90000|0x20000, Rich1.Hwnd)                           ;  EM_SETEVENTMASK

    Rich1.OnNotify(0x700, EN_MSGFILTER, 1)
    Rich1.OnNotify(0x702, EN_SELCHANGE, 1)

    PostMessage(0xB1, 0, 0, Rich1.Hwnd)
    ControlSetText(0, Edit2.Hwnd)

    TickCount  :=  Format("{:.15g}", (A_TickCount-TickCount)/1000)
    Loading    :=  False
    MySB_Tip("Loading completed in " TickCount "s")
    Edit2.Focus()

    WinWaitClose(MyGui.Hwnd)
    Return 1
    ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                    ToggleEndian(*)
                    {
                        BigE   :=  ChkB2.Value
                        Bytes  :=  Bin.Size - UpDn1.Value
                        Bytes  :=  Bytes &gt; 191 ? 192 : Bytes
                        NumValues(Bin.Ptr + UpDn1.Value, Bytes)
                    }


                    SelectByte(*)
                    {
                        PostMessage(0xB1, UpDn1.Value*3, UpDn1.Value*3+3, Rich1.Hwnd)
                    }


                    EN_SELCHANGE(GuiControl, lParam)
                    {
                        CHARRANGE  :=  lParam+(A_PtrSize*3)
                        Rich1_Min  :=  NumGet(CHARRANGE, 0, "uint")
                        Rich1_Max  :=  NumGet(CHARRANGE, 4, "uint")

                        Edit2.OnEvent("Change", SelectByte, 0)
                        UpDn1.Value := Rich1_Min//3
                        Edit2.OnEvent("Change", SelectByte, 1)

                        Bytes  :=  Bin.Size - UpDn1.Value
                        Bytes  :=  Bytes &gt; 191 ? 192 : Bytes

                        Text3.Text  :=  BinToTxt(Bin.Ptr + UpDn1.Value, Bytes)
                        NumValues(Bin.Ptr + UpDn1.Value, Bytes)
                    }


                    EN_MSGFILTER(GuiControl, Param)
                    {
                        Local  Offset  :=  Param+(A_PtrSize*3)
                            ,  Msg     :=  NumGet(Offset, "uint")
                            ,  wParam  :=  NumGet(Offset+4, A_PtrSize*0, "ptr")
                            ,  Key

                         If  Msg = 0x101                                         ; WM_KEYUP := 0x101
                        and  IsNumber( Key := Chr(wparam) )
                        and  Key&gt;0 and Key&lt;9
                             UpDn1.Value  +=  GetKeyState("Shift", "P")
                                           ?  0 - Integer(Key)
                                           :  Integer(Key)
                    }


                    NumValues(Offset, Bytes)
                    {
                        Static Buf  :=  Buffer(8)
                        Local  Num
                            ,  Double := 0
                            ,  Float := 0
                            ,  NumType  :=  Bytes&gt;7 ? "uint64" : Bytes&gt;3 ? "uint" : Bytes&gt;1 ? "ushort" : "uchar"

                        Num  :=  Format("{:016X}", NumGet(offset, NumType))
                     ,  Num  :=  BigE

                             ?  Format("0x{15:}{16:}|0x{15:}{16:}{13:}{14:}|0x{15:}{16:}{13:}{14:}{11:}{12:}{09:}{10:}"
                                     . "|0x{15:}{16:}{13:}{14:}{11:}{12:}{09:}{10:}{07:}{08:}{05:}{06:}{03:}{04:}{01:}{02:}"
                                     ,  StrSplit(Num)*)

                             :  Format("0x{15:}{16:}|0x{13:}{14:}{15:}{16:}|0x{09:}{10:}{11:}{12:}{13:}{14:}{15:}{16:}"
                                     . "|0x{01:}{02:}{03:}{04:}{05:}{06:}{07:}{08:}{09:}{10:}{11:}{12:}{13:}{14:}{15:}{16:}"
                                     ,  StrSplit(Num)*)

                     ,  Num  :=  StrSplit(Num, "|")

                        Double  :=  NumGet(NumPut("int64", Num[4], Buf, ) - 8, "double")
                     ,  Double  :=  Format("{:.15g}", Double)
                     ,  Double  :=  StrLen(Double) &gt; 16 ? "" : Double

                        Float   :=  NumGet(NumPut("uint", Num[3], Buf) - 4, "float")
                     ,  Float   :=  Format("{:.7g}", Float)

                        Edit1.Text := Format( "Char  {1:11} {2:11}             Float`r`n"
                                            . "Short {3:11} {4:11}  {5:16}`r`n"
                                            . "Int   {6:11} {7:11}            Double`r`n"
                                            . "Int64 {8:23}  {9:16}"
                                            , NumGet( NumPut("uchar",  Num[1], Buf)-1, "uchar" )
                                            , NumGet( NumPut("char",   Num[1], Buf)-1, "char"  )
                                            , NumGet( NumPut("ushort", Num[2], Buf)-2, "ushort")
                                            , NumGet( NumPut("short",  Num[2], Buf)-2, "short" )
                                            , Float
                                            , NumGet( NumPut("uint",   Num[3], Buf)-4, "uint"  )
                                            , NumGet( NumPut("int",    Num[3], Buf)-4, "int"   )
                                            , NumGet( NumPut("int64",  Num[4], Buf)-8, "int64" )
                                            , Double
                                            )
                    }


                    RichEdit_SetPropertyBits(hRich)
                    {
                        Local  OnTxPropertyBitsChange  :=  19               ; &lt;= Thanks swagfag @ autohotkey.com/r/?p=402594
                            ,  Unknown
                            ,  pUnknown
                            ,  TxtSrv
                            ,  IID_ITextServices       :=  "{8D33F740-CF58-11CE-A89D-00AA006CADC5}"

                        SendMessage(0x43C, 0, Unknown  :=  Buffer(8), hRich)     ; EM_GETOLEINTERFACE
                        pUnknown  :=  NumGet(Unknown, "ptr")
                        TxtSrv    :=  ComObjQuery(pUnknown, IID_ITextServices)
                        ObjRelease(pUnknown)

                        If  A_Ptrsize = 8
                        {
                            ComCall(OnTxPropertyBitsChange, TxtSrv, "int",0x802, "int",0x2)  
                            TxtSrv :=  ""
                            Return
                        }
                                                                               ; Thanks lexikos @ autohotkey.com/r/?p=402798

                        Local  vtbl                    :=  NumGet(TxtSrv.Ptr, "ptr")
                            ,  pOnTxPropertyBitsChange :=  NumGet(vtbl + (19 * A_PtrSize), "ptr")
                            ,  thiscall_thunk          :=  Buffer(8)

                        NumPut("int64", 0xE2FF50595A58, thiscall_thunk)
                        DllCall("Kernel32\VirtualProtect", "ptr",thiscall_thunk, "ptr",8, "int",0x40, "uint*",0)
                        DllCall(thiscall_thunk, "ptr",pOnTxPropertyBitsChange, "ptr",TxtSrv, "int",0x802, "int",0x2)
                        TxtSrv  :=  ""
                    }


                    BufferToSHex(&amp;Buf)
                    {
                        Static mCode
                        Local  mSz, Hex

                        If  not IsSet(mCode)
                            mSz := A_PtrSize=8 ? 128 : 105
                         ,  mcode := Buffer(mSz)
                         ,  DllCall("Kernel32\VirtualProtect", "ptr",mcode, "ptr",mSz, "int",0x40, "int*",0)
                         ,  DllCall("Crypt32\CryptStringToBinary"
                                  , "str",A_PtrSize=8

                                  ? "U1ZFhcB2djHARTHJDx9AAEGJwkYPthQRRYnTQcHrBESI20GD+wlAD5fWQPbeQIDmB0CAxjBAAPNEic6IHDJFid"
                                  . "NBg+MPRYjaQYP7CUEPl9NB9ttBgOMHQYDDMEUA2mdFjVkBRogUGmdFjVECQsYEEiBBg8EDg8ABRDnAcpNeW8M="

                                  : "VYnlg+wEU1ZXi30Mg30QAHZQMfYx24tNCA+2DDGJTfzB6QSIyoP5CQ+X0PbYJAcEMADCiBQfi1X8idGD4Q+Iyo"
                                  . "P5CQ+X0fbZgOEHgMEwAMqIVB8BxkQfAiCDwwNGO3UQcrRfXluJ7F3D"

                                  , "int",A_PtrSize=8 ? 172 : 140, "int",0x1, "ptr",mCode, "int*",mSz, "int",0, "int",0)

                        Hex := Buffer((Buf.Size*3) + 2)                                     ; put a trailing null terminator
                        NumPut("ushort", 0, Hex, Hex.Size-2)
                        DllCall(mCode, "ptr",Buf, "ptr",Hex, "int",Buf.Size, "cdecl")

                        Return Hex
                    }


                    BinToTxt(pBin, Bytes:=192)
                    {
                        Static mCode
                        Local  mSz, Txt, LF := Chr(10)

                        If  not IsSet(mCode)
                            mSz := A_PtrSize=8 ? 100 : 86
                         ,  mcode := Buffer(mSz)
                         ,  DllCall("Kernel32\VirtualProtect", "ptr",mcode, "ptr",mSz, "int",0x40, "int*",0)
                         ,  DllCall("Crypt32\CryptStringToBinary"
                                  , "str",A_PtrSize=8

                                  ? "U1ZFhcB2WjHARTHJQYnCRg+2HBFBg/sgcwe7LgAAAOsqQbouAAAAQYH7rQAAAEEPRfNBD0TyQbouAAAAQYPrf0"
                                  . "GD+yFBD0baD0feRYnKQYjbRogcEkGDwQGDwAFEOcByq15bww=="

                                  : "U1ZXg3wkGAB2SDHAMdKLTCQQD7YMAYP5IHMHvi4AAADrH78uAAAAgfmtAAAAD0X5uy4AAACD6X+D+SEPRvMPR/"
                                  . "eLTCQUifOIHBFCQDtEJBhyvF9eW8M="

                                  , "int",A_PtrSize=8 ? 136 : 116, "int",0x1, "ptr",mCode, "int*",mSz, "int",0, "int",0)

                        Txt := Buffer(Bytes, 0)
                        DllCall(mCode, "ptr",pBin, "ptr",Txt, "int",Bytes, "cdecl")
                        Txt := StrGet(Txt, "cp0")

                        Return SubStr(Txt,  1,48) LF SubStr(Txt,  49,48) LF
                             . SubStr(Txt, 97,48) LF SubStr(Txt, 145,48)
                    }


                    Search(*)
                    {
                        Local  Val  :=  Edit3.Text
                             , Pos  :=  0

                        If  not InStr(Val, ":")
                            Return

                        Try  Pos  :=  InBinary(&amp;Bin, Val)

                        If   ReverseSearch = 0 and UpDn1.Value = Pos-1
                             Try  UpDn1.Value += 1
                               ,  Pos  :=  InBinary(&amp;Bin, Val)
                               ,  UpDn1.Value += Pos ? 0 : -1

                        If   ReverseSearch = 1 and UpDn1.Value = Pos-1
                             Try  UpDn1.Value -= 1
                               ,  Pos  :=  InBinary(&amp;Bin, Val)
                               ,  UpDn1.Value += Pos ? 0 : +1

                        If not Pos
                           Return MySB_Tip("Not found " Val)

                        UpDn1.Value := Pos-1
                    }


                    InBinary(&amp;HayBuffer, Val)
                    {
                        Val  :=  StrSplit(Val, ":",, 2)

                        Local  valtype      :=  Val[1]
                             , value        :=  Val[2]
                             , Needle
                             , Len
                             , Bytes        :=  0
                             , Unicode      :=  0
                             , StartingPos  
                             , Buf          :=  Buffer(8, 0)

                        Local NumTypes := { double:8,float:4,uint64:8,int64:8,uint:4,int:4,ushort:2
                                          , short:2,uptr:8,ptr:8,uchar:1,char:1 }

                          If  IsNumber(valtype) and (valtype&gt;0 and valtype&lt;9)
                              NumPut("uint64", value, Buf)
                           ,  Needle := Buffer(valtype)
                           ,  DllCall("Kernel32\RtlMoveMemory", "ptr",Needle, "ptr",Buf, "ptr",valtype)

                        Else

                          If  valtype  =   ""
                              value    :=  StrReplace(value, A_Space)
                           ,  Len      :=  StrLen(value)
                           ,  Bytes    :=  Ceil(Len/2)
                           ,  Needle   :=  Buffer(Bytes)
                           ,  DllCall("Crypt32\CryptStringToBinary"
                                    , "str",value, "int",Len, "int",12, "ptr",Needle, "uintp",Bytes, "int",0, "int",0)

                        Else

                          If  HasProp( NumTypes, valtype)
                              Needle := Buffer(NumTypes.%valtype%)
                           ,  NumPut(valtype, value, Needle)

                        Else

                        Try   Needle  :=  Buffer(StrPut(Value,valtype))
                           ,  Bytes   :=  StrPut(Value, Needle, valtype)
                           ,  Unicode :=  NumGet(Needle, Needle.Size-2, "ushort") = 0
                           ,  Needle  :=  Buffer( Bytes-1-Unicode)
                           ,  StrPut(Value, Needle, valtype)

                        StartingPos := ReverseSearch = 0 ? UpDn1.Value + 1 : UpDn1.Value - HayBuffer.Size + Needle.Size
                        If  ReverseSearch and StartingPos&gt;0
                            StartingPos := 0

                        Return InBuffer(&amp;HayBuffer, &amp;Needle, StartingPos)
                    }


                    InBuffer(&amp;HayBuffer, &amp;NeedleBuffer, StartingPos)
                    {
                        Static mCode
                        Local  mSz, Hex, Pos := 0

                        If  not IsSet(mCode)
                            mSz := A_PtrSize=8 ? 183 : 180
                         ,  mcode := Buffer(mSz)
                         ,  DllCall("Kernel32\VirtualProtect", "ptr",mcode, "ptr",mSz, "int",0x40, "int*",0)
                         ,  DllCall("Crypt32\CryptStringToBinary"
                                  , "str",A_PtrSize=8

                                  ? "U1ZXQVSLRCRIRItcJFCJ00Qpy4XAvgEAAABBuv////9BD07yhcB+B2dEjVD/6wgBwkGJ0kUpykSJ0kGD6QE52n"
                                  . "dnMcBBidJBijhCODwRdU9FicpHihQQZ0KNPApEOBQ5dT1Bg/kCci9BugEAAABBg/kBdh5EiddBijw4Z0aNJBJF"
                                  . "ieRCODwhdQlBg8IBRTnKcuJFOcp1A4PAAUQ52HQOAfKF0nIEOdp2mzHA6wRnjUIBQVxfXlvD"

                                  : "VYnlg+wMU1ZXi1UUi0UMKdCJRfQxwIN9GAAPntD32IPg/kCJRfiDfRgAfgmLRRhIiUX86wuLRQwDRRgp0IlF/I"
                                  . "tF/InBSjtN9HdbMcCLdQiKHA6LdRA6HnVAjTQRi30Iihw3i3UQOhwWdS+D+gJyJL4BAAAAg/oBdhaNPDGLXQiK"
                                  . "HDuLfRA6HDd1BUY51nLqOdZ1AUA7RRx0EANN+IXJcgU7TfR2pzHA6wONQQFfXluJ7F3D"

                                  , "int",A_PtrSize=8 ? 244 : 240, "int",0x1, "ptr",mCode, "int*",mSz, "int",0, "int",0)

                        Try  Pos := DllCall(mCode, "ptr",HayBuffer,      "int",HayBuffer.Size
                                                 , "ptr",NeedleBuffer, "short",NeedleBuffer.Size
                                                 , "int",StartingPos,    "int",1
                                                 , "cdecl uint")

                        Return Pos
                    }
} ; ________________________________________________________________________________________________________________________</Item>
			<Item name="win_ocr" tv="10205920">#NoEnv
SetBatchLines, -1
Return

Esc:: ExitApp

^X::
hBitmap := HBitmapFromScreen(GetArea()*)
pIRandomAccessStream := HBitmapToRandomAccessStream(hBitmap)
DllCall("DeleteObject", "Ptr", hBitmap)
text := ocr(pIRandomAccessStream, "ru")
MsgBox, % text
Return

GetArea() {
   area := []
   StartSelection(area)
   while !area.w
      Sleep, 100
   Return area
}
   
StartSelection(area) {
   handler := Func("Select").Bind(area)
   Hotkey, LButton, % handler, On
   ReplaceSystemCursors("IDC_CROSS")
}

Select(area) {
   static hGui := CreateSelectionGui()
   Hook := new WindowsHook(WH_MOUSE_LL := 14, "LowLevelMouseProc", hGui)
   Loop {
      KeyWait, LButton
      WinGetPos, X, Y, W, H, ahk_id %hGui%
   } until w &gt; 0
   ReplaceSystemCursors("")
   Hotkey, LButton, Off
   Hook := ""
   Gui, %hGui%:Show, Hide
   for k, v in ["x", "y", "w", "h"]
      area[v] := %v%
}

ReplaceSystemCursors(IDC = "")
{
   static IMAGE_CURSOR := 2, SPI_SETCURSORS := 0x57
        , exitFunc := Func("ReplaceSystemCursors").Bind("")
        , SysCursors := { IDC_APPSTARTING: 32650
                        , IDC_ARROW      : 32512
                        , IDC_CROSS      : 32515
                        , IDC_HAND       : 32649
                        , IDC_HELP       : 32651
                        , IDC_IBEAM      : 32513
                        , IDC_NO         : 32648
                        , IDC_SIZEALL    : 32646
                        , IDC_SIZENESW   : 32643
                        , IDC_SIZENWSE   : 32642
                        , IDC_SIZEWE     : 32644
                        , IDC_SIZENS     : 32645 
                        , IDC_UPARROW    : 32516
                        , IDC_WAIT       : 32514 }
   if !IDC {
      DllCall("SystemParametersInfo", UInt, SPI_SETCURSORS, UInt, 0, UInt, 0, UInt, 0)
      OnExit(exitFunc, 0)
   }
   else  {
      hCursor := DllCall("LoadCursor", Ptr, 0, UInt, SysCursors[IDC], Ptr)
      for k, v in SysCursors  {
         hCopy := DllCall("CopyImage", Ptr, hCursor, UInt, IMAGE_CURSOR, Int, 0, Int, 0, UInt, 0, Ptr)
         DllCall("SetSystemCursor", Ptr, hCopy, UInt, v)
      }
      OnExit(exitFunc)
   }
}

CreateSelectionGui() {
   Gui, New, +hwndhGui +Alwaysontop -Caption +LastFound +ToolWindow +E0x20 -DPIScale
   WinSet, Transparent, 130
   Gui, Color, FFC800
   Return hGui
}

LowLevelMouseProc(nCode, wParam, lParam) {
   static WM_MOUSEMOVE := 0x200, WM_LBUTTONUP := 0x202
        , coords := [], startMouseX, startMouseY, hGui
        , timer := Func("LowLevelMouseProc").Bind("timer", "", "")
   
   if (nCode = "timer") {
      while coords[1] {
         point := coords.RemoveAt(1)
         mouseX := point[1], mouseY := point[2]
         x := startMouseX &lt; mouseX ? startMouseX : mouseX
         y := startMouseY &lt; mouseY ? startMouseY : mouseY
         w := Abs(mouseX - startMouseX)
         h := Abs(mouseY - startMouseY)
         try Gui, %hGUi%: Show, x%x% y%y% w%w% h%h% NA
      }
   }
   else {
      (!hGui &amp;&amp; hGui := A_EventInfo)
      if (wParam = WM_LBUTTONUP)
         startMouseX := startMouseY := ""
      if (wParam = WM_MOUSEMOVE)  {
         mouseX := NumGet(lParam + 0, "Int")
         mouseY := NumGet(lParam + 4, "Int")
         if (startMouseX = "") {
            startMouseX := mouseX
            startMouseY := mouseY
         }
         coords.Push([mouseX, mouseY])
         SetTimer, % timer, -10
      }
      Return DllCall("CallNextHookEx", Ptr, 0, Int, nCode, UInt, wParam, Ptr, lParam)
   }
}

class WindowsHook {
   __New(type, callback, eventInfo := "", isGlobal := true) {
      this.callbackPtr := RegisterCallback(callback, "Fast", 3, eventInfo)
      this.hHook := DllCall("SetWindowsHookEx", "Int", type, "Ptr", this.callbackPtr
                                              , "Ptr", !isGlobal ? 0 : DllCall("GetModuleHandle", "UInt", 0, "Ptr")
                                              , "UInt", isGlobal ? 0 : DllCall("GetCurrentThreadId"), "Ptr")
   }
   __Delete() {
      DllCall("UnhookWindowsHookEx", "Ptr", this.hHook)
      DllCall("GlobalFree", "Ptr", this.callBackPtr, "Ptr")
   }
}

HBitmapFromScreen(X, Y, W, H) {
   HDC := DllCall("GetDC", "Ptr", 0, "UPtr")
   HBM := DllCall("CreateCompatibleBitmap", "Ptr", HDC, "Int", W, "Int", H, "UPtr")
   PDC := DllCall("CreateCompatibleDC", "Ptr", HDC, "UPtr")
   DllCall("SelectObject", "Ptr", PDC, "Ptr", HBM)
   DllCall("BitBlt", "Ptr", PDC, "Int", 0, "Int", 0, "Int", W, "Int", H
                   , "Ptr", HDC, "Int", X, "Int", Y, "UInt", 0x00CC0020)
   DllCall("DeleteDC", "Ptr", PDC)
   DllCall("ReleaseDC", "Ptr", 0, "Ptr", HDC)
   Return HBM
}

HBitmapToRandomAccessStream(hBitmap) {
   static IID_IRandomAccessStream := "{905A0FE1-BC53-11DF-8C49-001E4FC686DA}"
        , IID_IPicture            := "{7BF80980-BF32-101A-8BBB-00AA00300CAB}"
        , PICTYPE_BITMAP := 1
        , BSOS_DEFAULT   := 0
        
   DllCall("Ole32\CreateStreamOnHGlobal", "Ptr", 0, "UInt", true, "PtrP", pIStream, "UInt")
   
   VarSetCapacity(PICTDESC, sz := 8 + A_PtrSize*2, 0)
   NumPut(sz, PICTDESC)
   NumPut(PICTYPE_BITMAP, PICTDESC, 4)
   NumPut(hBitmap, PICTDESC, 8)
   riid := CLSIDFromString(IID_IPicture, GUID1)
   DllCall("OleAut32\OleCreatePictureIndirect", "Ptr", &amp;PICTDESC, "Ptr", riid, "UInt", false, "PtrP", pIPicture, "UInt")
   ; IPicture::SaveAsFile
   DllCall(NumGet(NumGet(pIPicture+0) + A_PtrSize*15), "Ptr", pIPicture, "Ptr", pIStream, "UInt", true, "UIntP", size, "UInt")
   riid := CLSIDFromString(IID_IRandomAccessStream, GUID2)
   DllCall("ShCore\CreateRandomAccessStreamOverStream", "Ptr", pIStream, "UInt", BSOS_DEFAULT, "Ptr", riid, "PtrP", pIRandomAccessStream, "UInt")
   ObjRelease(pIPicture)
   ObjRelease(pIStream)
   Return pIRandomAccessStream
}

CLSIDFromString(IID, ByRef CLSID) {
   VarSetCapacity(CLSID, 16, 0)
   if res := DllCall("ole32\CLSIDFromString", "WStr", IID, "Ptr", &amp;CLSID, "UInt")
      throw Exception("CLSIDFromString failed. Error: " . Format("{:#x}", res))
   Return &amp;CLSID
}


ocr(file, lang := "FirstFromAvailableLanguages")
{
   static OcrEngineStatics, OcrEngine, MaxDimension, LanguageFactory, Language, CurrentLanguage, BitmapDecoderStatics, GlobalizationPreferencesStatics
   if (OcrEngineStatics = "")
   {
      CreateClass("Windows.Globalization.Language", ILanguageFactory := "{9B0252AC-0C27-44F8-B792-9793FB66C63E}", LanguageFactory)
      CreateClass("Windows.Graphics.Imaging.BitmapDecoder", IBitmapDecoderStatics := "{438CCB26-BCEF-4E95-BAD6-23A822E58D01}", BitmapDecoderStatics)
      CreateClass("Windows.Media.Ocr.OcrEngine", IOcrEngineStatics := "{5BFFA85A-3384-3540-9940-699120D428A8}", OcrEngineStatics)
      DllCall(NumGet(NumGet(OcrEngineStatics+0)+6*A_PtrSize), "ptr", OcrEngineStatics, "uint*", MaxDimension)   ; MaxImageDimension
   }
   if (file = "ShowAvailableLanguages")
   {
      if (GlobalizationPreferencesStatics = "")
         CreateClass("Windows.System.UserProfile.GlobalizationPreferences", IGlobalizationPreferencesStatics := "{01BF4326-ED37-4E96-B0E9-C1340D1EA158}", GlobalizationPreferencesStatics)
      DllCall(NumGet(NumGet(GlobalizationPreferencesStatics+0)+9*A_PtrSize), "ptr", GlobalizationPreferencesStatics, "ptr*", LanguageList)   ; get_Languages
      DllCall(NumGet(NumGet(LanguageList+0)+7*A_PtrSize), "ptr", LanguageList, "int*", count)   ; count
      loop % count
      {
         DllCall(NumGet(NumGet(LanguageList+0)+6*A_PtrSize), "ptr", LanguageList, "int", A_Index-1, "ptr*", hString)   ; get_Item
         DllCall(NumGet(NumGet(LanguageFactory+0)+6*A_PtrSize), "ptr", LanguageFactory, "ptr", hString, "ptr*", LanguageTest)   ; CreateLanguage
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+8*A_PtrSize), "ptr", OcrEngineStatics, "ptr", LanguageTest, "int*", bool)   ; IsLanguageSupported
         if (bool = 1)
         {
            DllCall(NumGet(NumGet(LanguageTest+0)+6*A_PtrSize), "ptr", LanguageTest, "ptr*", hText)
            buffer := DllCall("Combase.dll\WindowsGetStringRawBuffer", "ptr", hText, "uint*", length, "ptr")
            text .= StrGet(buffer, "UTF-16") "`n"
         }
         ObjRelease(LanguageTest)
      }
      ObjRelease(LanguageList)
      return text
   }
   if (lang != CurrentLanguage) or (lang = "FirstFromAvailableLanguages")
   {
      if (OcrEngine != "")
      {
         ObjRelease(OcrEngine)
         if (CurrentLanguage != "FirstFromAvailableLanguages")
            ObjRelease(Language)
      }
      if (lang = "FirstFromAvailableLanguages")
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+10*A_PtrSize), "ptr", OcrEngineStatics, "ptr*", OcrEngine)   ; TryCreateFromUserProfileLanguages
      else
      {
         CreateHString(lang, hString)
         DllCall(NumGet(NumGet(LanguageFactory+0)+6*A_PtrSize), "ptr", LanguageFactory, "ptr", hString, "ptr*", Language)   ; CreateLanguage
         DeleteHString(hString)
         DllCall(NumGet(NumGet(OcrEngineStatics+0)+9*A_PtrSize), "ptr", OcrEngineStatics, ptr, Language, "ptr*", OcrEngine)   ; TryCreateFromLanguage
      }
      if (OcrEngine = 0)
      {
         msgbox Can not use language "%lang%" for OCR, please install language pack.
         ExitApp
      }
      CurrentLanguage := lang
   }
   IRandomAccessStream := file
   DllCall(NumGet(NumGet(BitmapDecoderStatics+0)+14*A_PtrSize), "ptr", BitmapDecoderStatics, "ptr", IRandomAccessStream, "ptr*", BitmapDecoder)   ; CreateAsync
   WaitForAsync(BitmapDecoder)
   BitmapFrame := ComObjQuery(BitmapDecoder, IBitmapFrame := "{72A49A1C-8081-438D-91BC-94ECFC8185C6}")
   DllCall(NumGet(NumGet(BitmapFrame+0)+12*A_PtrSize), "ptr", BitmapFrame, "uint*", width)   ; get_PixelWidth
   DllCall(NumGet(NumGet(BitmapFrame+0)+13*A_PtrSize), "ptr", BitmapFrame, "uint*", height)   ; get_PixelHeight
   if (width &gt; MaxDimension) or (height &gt; MaxDimension)
   {
      msgbox Image is to big - %width%x%height%.`nIt should be maximum - %MaxDimension% pixels
      ExitApp
   }
   BitmapFrameWithSoftwareBitmap := ComObjQuery(BitmapDecoder, IBitmapFrameWithSoftwareBitmap := "{FE287C9A-420C-4963-87AD-691436E08383}")
   DllCall(NumGet(NumGet(BitmapFrameWithSoftwareBitmap+0)+6*A_PtrSize), "ptr", BitmapFrameWithSoftwareBitmap, "ptr*", SoftwareBitmap)   ; GetSoftwareBitmapAsync
   WaitForAsync(SoftwareBitmap)
   DllCall(NumGet(NumGet(OcrEngine+0)+6*A_PtrSize), "ptr", OcrEngine, ptr, SoftwareBitmap, "ptr*", OcrResult)   ; RecognizeAsync
   WaitForAsync(OcrResult)
   DllCall(NumGet(NumGet(OcrResult+0)+6*A_PtrSize), "ptr", OcrResult, "ptr*", LinesList)   ; get_Lines
   DllCall(NumGet(NumGet(LinesList+0)+7*A_PtrSize), "ptr", LinesList, "int*", count)   ; count
   loop % count
   {
      DllCall(NumGet(NumGet(LinesList+0)+6*A_PtrSize), "ptr", LinesList, "int", A_Index-1, "ptr*", OcrLine)
      DllCall(NumGet(NumGet(OcrLine+0)+7*A_PtrSize), "ptr", OcrLine, "ptr*", hText) 
      buffer := DllCall("Combase.dll\WindowsGetStringRawBuffer", "ptr", hText, "uint*", length, "ptr")
      text .= StrGet(buffer, "UTF-16") "`n"
      ObjRelease(OcrLine)
   }
   Close := ComObjQuery(IRandomAccessStream, IClosable := "{30D5A829-7FA4-4026-83BB-D75BAE4EA99E}")
   DllCall(NumGet(NumGet(Close+0)+6*A_PtrSize), "ptr", Close)   ; Close
   ObjRelease(Close)
   Close := ComObjQuery(SoftwareBitmap, IClosable := "{30D5A829-7FA4-4026-83BB-D75BAE4EA99E}")
   DllCall(NumGet(NumGet(Close+0)+6*A_PtrSize), "ptr", Close)   ; Close
   ObjRelease(Close)
   ObjRelease(IRandomAccessStream)
   ObjRelease(BitmapDecoder)
   ObjRelease(BitmapFrame)
   ObjRelease(BitmapFrameWithSoftwareBitmap)
   ObjRelease(SoftwareBitmap)
   ObjRelease(OcrResult)
   ObjRelease(LinesList)
   return text
}



CreateClass(string, interface, ByRef Class)
{
   CreateHString(string, hString)
   VarSetCapacity(GUID, 16)
   DllCall("ole32\CLSIDFromString", "wstr", interface, "ptr", &amp;GUID)
   result := DllCall("Combase.dll\RoGetActivationFactory", "ptr", hString, "ptr", &amp;GUID, "ptr*", Class)
   if (result != 0)
   {
      if (result = 0x80004002)
         msgbox No such interface supported
      else if (result = 0x80040154)
         msgbox Class not registered
      else
         msgbox error: %result%
      ExitApp
   }
   DeleteHString(hString)
}

CreateHString(string, ByRef hString)
{
    DllCall("Combase.dll\WindowsCreateString", "wstr", string, "uint", StrLen(string), "ptr*", hString)
}

DeleteHString(hString)
{
   DllCall("Combase.dll\WindowsDeleteString", "ptr", hString)
}

WaitForAsync(ByRef Object)
{
   AsyncInfo := ComObjQuery(Object, IAsyncInfo := "{00000036-0000-0000-C000-000000000046}")
   loop
   {
      DllCall(NumGet(NumGet(AsyncInfo+0)+7*A_PtrSize), "ptr", AsyncInfo, "uint*", status)   ; IAsyncInfo.Status
      if (status != 0)
      {
         if (status != 1)
         {
            DllCall(NumGet(NumGet(AsyncInfo+0)+8*A_PtrSize), "ptr", AsyncInfo, "uint*", ErrorCode)   ; IAsyncInfo.ErrorCode
            msgbox AsyncInfo status error: %ErrorCode%
            ExitApp
         }
         ObjRelease(AsyncInfo)
         break
      }
      sleep 10
   }
   DllCall(NumGet(NumGet(Object+0)+8*A_PtrSize), "ptr", Object, "ptr*", ObjectResult)   ; GetResults
   ObjRelease(Object)
   Object := ObjectResult
}</Item>
			<Item name="data dump" tv="10203904">run, https://www.autohotkey.com/boards/viewtopic.php?t=3573</Item>
			<Item name="capture" tv="10206592">run,G:\我的AHK程序\我的工程\dxgi_pixelgetcolor
c =
(%
#include &lt;my_lib&gt;

;gdip startup
if !DllCall("kernel32\GetModuleHandle", Str,"gdiplus", Ptr)
	DllCall("kernel32\LoadLibrary", Str,"gdiplus", Ptr)
VarSetCapacity(GdiplusStartupInput, 16, 0), GdiplusStartupInput := Chr(1)
DllCall("gdiplus\GdiplusStartup", UPtrP,pToken, Ptr,&amp;GdiplusStartupInput, Ptr,0)

Gui +AlwaysOnTop -DPIScale
Gui Margin, 15, 15
Gui Add, Pic, HwndhPic w800 h800 +Border	;演示窗口大小
Gui Show,x1000 y10

;==============================
;from data
vSize := 14 + 40 + A_ScreenWidth * A_ScreenHeight * 4
dxgi_init(0)
rtn := dxgi_pixelgetcolor(0, 0, p_vitmap_file, p_bitmap_info , p_bitmap_data, is_time_out)
dxgi_save2file("test.bmp")
loop
{
    dxgi_pixelgetcolor(0, 0, p_vitmap_file, p_bitmap_info , p_bitmap_data, is_time_out)
    hBitmap := GDIPlus_hBitmapFromPoint(p_vitmap_file, vSize)
    Show(hPic, hBitmap, 0, 0, 800, 800)
    DllCall("DeleteObject", "ptr", hBitmap)
}
return

f5::
;gdip shutdown
DllCall("gdiplus\GdiplusShutdown", UPtr,pToken)
if hModule := DllCall("kernel32\GetModuleHandle", Str,"gdiplus", Ptr)
	DllCall("kernel32\FreeLibrary", Ptr,hModule)
;==============================
ExitApp
return

;==================================================
;GdiPlus_SaveImageToBuffer() - Scripts and Functions - AutoHotkey Community
;https://autohotkey.com/board/topic/85523-gdiplus-saveimagetobuffer/

GDIPlus_hBitmapFromPoint( ByRef Buffer, nSize ) { ;  Last Modifed : 21-Jun-2011
; Adapted version by SKAN www.autohotkey.com/forum/viewtopic.php?p=383863#383863
; Original code   by Sean www.autohotkey.com/forum/viewtopic.php?p=147029#147029
 hData := DllCall("GlobalAlloc", UInt,2, UInt,nSize )
 pData := DllCall("GlobalLock",  UInt,hData )
 DllCall( "RtlMoveMemory", UInt,pData, UInt,Buffer, UInt,nSize )
 DllCall( "GlobalUnlock" , UInt,hData )
 DllCall( "ole32\CreateStreamOnHGlobal", UInt,hData, Int,True, UIntP,pStream )
 DllCall( "gdiplus\GdipCreateBitmapFromStream",  UInt,pStream, UIntP,pBitmap )
 DllCall( "gdiplus\GdipCreateHBITMAPFromBitmap", UInt,pBitmap, UIntP,hBitmap, UInt
,DllCall( "ntdll\RtlUlongByteSwap",UInt
,DllCall( "GetSysColor", Int,15 ) &lt;&lt;8 ) | 0xFF000000 )
 DllCall( "gdiplus\GdipDisposeImage", UInt,pBitmap )
 DllCall( NumGet( NumGet(1*pStream)+8 ), UInt,pStream ) ; IStream::Release
 Dllcall("GlobalFree", "Ptr", hData)
Return hBitmap
}


GDIPlus_hBitmapFromBuffer( ByRef Buffer, nSize ) { ;  Last Modifed : 21-Jun-2011
; Adapted version by SKAN www.autohotkey.com/forum/viewtopic.php?p=383863#383863
; Original code   by Sean www.autohotkey.com/forum/viewtopic.php?p=147029#147029
 hData := DllCall("GlobalAlloc", UInt,2, UInt,nSize )
 pData := DllCall("GlobalLock",  UInt,hData )
 DllCall( "RtlMoveMemory", UInt,pData, UInt,&amp;Buffer, UInt,nSize )
 DllCall( "GlobalUnlock" , UInt,hData )
 DllCall( "ole32\CreateStreamOnHGlobal", UInt,hData, Int,True, UIntP,pStream )
 DllCall( "gdiplus\GdipCreateBitmapFromStream",  UInt,pStream, UIntP,pBitmap )
 DllCall( "gdiplus\GdipCreateHBITMAPFromBitmap", UInt,pBitmap, UIntP,hBitmap, UInt
,DllCall( "ntdll\RtlUlongByteSwap",UInt
,DllCall( "GetSysColor", Int,15 ) &lt;&lt;8 ) | 0xFF000000 )
 DllCall( "gdiplus\GdipDisposeImage", UInt,pBitmap )
 DllCall( NumGet( NumGet(1*pStream)+8 ), UInt,pStream ) ; IStream::Release
 Dllcall("GlobalFree", "Ptr", hData)
Return hBitmap
}

;----------------------
; 显示内存图像  By FeiYue
;----------------------
Show(hwnd, hBM, x1, y1, x2, y2) {
	x:=Min(x1,x2), y:=Min(y1,y2), w:=Abs(x2-x1)+1, h:=Abs(y2-y1)+1
	, hDC := DllCall("GetDC", "Ptr",hwnd, "Ptr")
	, mDC := DllCall("CreateCompatibleDC", "Ptr", hDC, "Ptr")
	, oBM := DllCall("SelectObject", "Ptr", mDC, "Ptr", hBM)
	rtn := DllCall("BitBlt", "Ptr", hDC, "Int",0, "Int",0, "Int",w, "Int",h, "Ptr",mDC, "Int",x, "Int",y, "UInt",0xCC0020)
	DllCall("SelectObject", "Ptr", mDC, "Ptr", oBM)
	, DllCall("ReleaseDC", "Ptr",hwnd, "Ptr",hDC)
	, DllCall("DeleteDC", "Ptr",mDC)
}
)
Clipboard := c</Item>
			<Item name="右键选择范围byfeiyue" tv="10206032">;------------------------------
; 右键选择屏幕范围   By FeiYue
;------------------------------

F1:: MsgBox, 4096,, % "选择的范围是：" 右键选择屏幕范围(x1,y1,x2,y2)

右键选择屏幕范围(ByRef x1="", ByRef y1="", ByRef x2="", ByRef y2="")
{
  KeyWait, RButton
  For k,v in StrSplit("RButton,Left,Right,Up,Down", ",")
    Hotkey, % v, GetRange_KeyOff, On
  if (0)
  {
    GetRange_KeyOff:
    return
  }
  Gui, GetRange: Destroy
  Gui, % "GetRange: +AlwaysOnTop -Caption +ToolWindow"
    . " +Hwndid -DPIScale +E0x08000000"
  ok:=0
  CoordMode, Mouse, Screen
  While !GetKeyState("Ctrl","P")
  {
    Sleep, 50
    ToolTip, 按右键拖选范围`n方向键微调位置`n再次点右键确定
    MouseGetPos, x2, y2
    if (ok=0)
    {
      if GetKeyState("RButton","P")
        ok:=1, x1:=x2, y1:=y2
    }
    else if (ok=1)
    {
      GetKeyState("Left","P")  &amp;&amp; x1--
      GetKeyState("Right","P") &amp;&amp; x1++
      GetKeyState("Up","P")    &amp;&amp; y1--
      GetKeyState("Down","P")  &amp;&amp; y1++
      w:=Floor(Abs(x1-x2)), h:=Floor(Abs(y1-y2))
      x:=Floor(Min(x1,x2)), y:=Floor(Min(y1,y2))
      d:=2, x-=d, y-=d, w+=2*d, h+=2*d, i:=w-d, j:=h-d
      s:="0-0 " (w "-0 ") (w "-" h) (" 0-" h) " 0-0  "
      . (d "-" d) " " (i "-" d) " " (i "-" j) " " (d "-" j) " " (d "-" d)
      WinSet, Region, %s%, ahk_id %id%
      Gui, GetRange: Color, % (A_MSec&lt;500 ? "Red":"Blue")
      Gui, GetRange: Show, NA x%x% y%y% w%w% h%h%
      if !GetKeyState("RButton","P")
        ok:=2
    }
    else if (ok=2)
    {
      GetKeyState("Left","P")  &amp;&amp; x--
      GetKeyState("Right","P") &amp;&amp; x++
      GetKeyState("Up","P")    &amp;&amp; y--
      GetKeyState("Down","P")  &amp;&amp; y++
      Gui, GetRange: Color, % (A_MSec&lt;500 ? "Red":"Blue")
      Gui, GetRange: Show, NA x%x% y%y%
      if GetKeyState("RButton","P")
        Break
    }
  }
  x1:=x+d, y1:=y+d, x2:=x+w-1-d, y2:=y+h-1-d
  Gui, GetRange: Destroy
  ToolTip
  KeyWait, RButton
  For k,v in StrSplit("RButton,Left,Right,Up,Down", ",")
    Hotkey, % v, Off
  return (x1 "," y1 "," x2 "," y2)
}
</Item>
			<Item name="外框高亮线条" tv="10204912">Outline := []
Outline[1] := new HighlightOutline("Blue", 128)
Outline[1].show(0, 0, 200, 200)
Outline[1].Destroy()
class HighlightOutline {
	__New(color="red", Transparent=255) {
		Loop 4 {
			Gui New, -Caption +AlwaysOnTop +ToolWindow HWNDhwnd -DPIScale +E0x20 +E0x00080000
			Gui Color, %color%
			DllCall("SetLayeredWindowAttributes", "Ptr", this[A_Index] := hwnd, "Uint", 0, "Uchar", Transparent, "int", 2)
		}
		this.top := this[1]
		, this.right := this[2]
		, this.bottom := this[3]
		, this.left := this[4]
		Gui % "Gui_Cheek_Number" A_DefaultGui ": Default"
	}
	
	Show(x1, y1, x2, y2, b=3) {
		Try {
			Gui % this.1 ":Show", % "NA x" x1-b " y" y1-b " w" x2-x1+b*2 " h" b
			Gui % this.2 ":Show", % "NA x" x2 " y" y1 " w" b " h" y2-y1	
			Gui % this.3 ":Show", % "NA x" x1-b " y" y2 " w" x2-x1+2*b " h" b
			Gui % this.4 ":Show", % "NA x" x1-b " y" y1 " w" b " h" y2-y1
		}
	}

	Hide() {
		Loop 4
			Try Gui % this[A_Index] ": Hide"
	}

	Destroy() {
		Loop 4
			Try Gui % this[A_Index] ": Destroy"
	}
}</Item>
			<Item name="内存信息" tv="10204240">OwnPID := DllCall("GetCurrentProcessId")
ProcessInformation(OwnPID)
mm := GetProcessMemoryUsage(OwnPID)
MsgBox("当前进程内存 :" mm)

Proc := ProcessInformation(OwnPID)
info := ""
for k, v in Proc
	info .=  k ": " v '`n'
MsgBox(info)

info := ""
Proc := SystemProcessInformation()
for i, v in Proc {
	for k, v in Proc[i]
		info .= k ": " v '`n'
}
MsgBox(info)

;获取制定进程内存
GetProcessMemoryUsage(ProcessID)
{
	static PMC_EX
    PMC_EX := Buffer(8 + A_PtrSize * 9, 0)
    size := PMC_EX.Size
	if (hProcess := DllCall("OpenProcess", "uint", 0x1000, "int", 0, "uint", ProcessID)) 
    {
		if !(DllCall("psapi\GetProcessMemoryInfo", "ptr", hProcess, "ptr", PMC_EX, "uint", size))
			return false
		DllCall("CloseHandle", "ptr", hProcess)
		return Round(NumGet(PMC_EX, 8 + A_PtrSize * 8, "uptr") / 1024**2, 2)
	}
	return false
}
;获取制定进程内存信息
ProcessInformation(PID)
{
	#DllLoad "ntdll.dll"

	static STATUS_SUCCESS              := 0x00000000
	static STATUS_INFO_LENGTH_MISMATCH := 0xC0000004
	static STATUS_BUFFER_TOO_SMALL     := 0xC0000023
	static SYSTEM_PROCESS_INFORMATION  := 0x00000005

	Buf := Buffer(0x0100, 0)
	NT_STATUS := DllCall("ntdll\NtQuerySystemInformation", "Int", SYSTEM_PROCESS_INFORMATION, "Ptr", Buf.Ptr, "UInt", Buf.Size, "UInt*", &amp;Size := 0, "UInt")

	while (NT_STATUS = STATUS_INFO_LENGTH_MISMATCH) || (NT_STATUS = STATUS_BUFFER_TOO_SMALL)
	{
		Buf := Buffer(Size, 0)
		NT_STATUS := DllCall("ntdll\NtQuerySystemInformation", "Int", SYSTEM_PROCESS_INFORMATION, "Ptr", Buf.Ptr, "UInt", Buf.Size, "UInt*", &amp;Size := 0, "UInt")
	}

	if (NT_STATUS = STATUS_SUCCESS)
	{
		Addr := Buf.Ptr
		while (Addr)
		{
			PROCESS := Map()
			PROCESS["NumberOfThreads"]              := NumGet(Addr, 0x0004, "UInt")
			PROCESS["WorkingSetPrivateSize"]        := NumGet(Addr, 0x0008, "Int64")
			PROCESS["HardFaultCount"]               := NumGet(Addr, 0x0010, "UInt")
			PROCESS["NumberOfThreadsHighWatermark"] := NumGet(Addr, 0x0014, "UInt")
			PROCESS["CycleTime"]                    := NumGet(Addr, 0x0018, "UInt64")
			PROCESS["CreateTime"]                   := NumGet(Addr, 0x0020, "Int64")
			PROCESS["UserTime"]                     := NumGet(Addr, 0x0028, "Int64")
			PROCESS["KernelTime"]                   := NumGet(Addr, 0x0030, "Int64")
			PROCESS["ImageName"]                    := (Ptr := NumGet(Addr, 0x0040, "Ptr")) ? StrGet(Ptr) : ""
			PROCESS["BasePriority"]                 := NumGet(Addr, 0x0048, "Int")
			PROCESS["UniqueProcessId"]              := NumGet(Addr, 0x0050, "Ptr")
			PROCESS["InheritedFromUniqueProcessId"] := NumGet(Addr, 0x0058, "Ptr*")
			PROCESS["HandleCount"]                  := NumGet(Addr, 0x0060, "UInt")
			PROCESS["SessionId"]                    := NumGet(Addr, 0x0064, "UInt")
			PROCESS["UniqueProcessKey"]             := NumGet(Addr, 0x0068, "UPtr")
			PROCESS["PeakVirtualSize"]              := NumGet(Addr, 0x0070, "UPtr")
			PROCESS["VirtualSize"]                  := NumGet(Addr, 0x0078, "UPtr")
			PROCESS["PageFaultCount"]               := NumGet(Addr, 0x0080, "UInt")
			PROCESS["PeakWorkingSetSize"]           := NumGet(Addr, 0x0088, "UPtr")
			PROCESS["WorkingSetSize"]               := NumGet(Addr, 0x0090, "UPtr")
			PROCESS["QuotaPeakPagedPoolUsage"]      := NumGet(Addr, 0x0098, "UPtr")
			PROCESS["QuotaPagedPoolUsage"]          := NumGet(Addr, 0x00A0, "UPtr")
			PROCESS["QuotaPeakNonPagedPoolUsage"]   := NumGet(Addr, 0x00A8, "UPtr")
			PROCESS["QuotaNonPagedPoolUsage"]       := NumGet(Addr, 0x00B0, "UPtr")
			PROCESS["PagefileUsage"]                := NumGet(Addr, 0x00B8, "UPtr")
			PROCESS["PeakPagefileUsage"]            := NumGet(Addr, 0x00C0, "UPtr")
			PROCESS["PrivatePageCount"]             := NumGet(Addr, 0x00C8, "UPtr")
			PROCESS["ReadOperationCount"]           := NumGet(Addr, 0x00D0, "Int64")
			PROCESS["WriteOperationCount"]          := NumGet(Addr, 0x00D8, "Int64")
			PROCESS["OtherOperationCount"]          := NumGet(Addr, 0x00E0, "Int64")
			PROCESS["ReadTransferCount"]            := NumGet(Addr, 0x00E8, "Int64")
			PROCESS["WriteTransferCount"]           := NumGet(Addr, 0x00F0, "Int64")
			PROCESS["OtherTransferCount"]           := NumGet(Addr, 0x00F8, "Int64")

            if(PROCESS["UniqueProcessId"] == PID)
                return PROCESS

			if !(NumGet(Addr, 0x0000, "UInt"))
				break
			Addr += NumGet(Addr, 0x0000, "UInt")
		}
	}
	return false
}

;获取所有进程信息
SystemProcessInformation()
{
	#DllLoad "ntdll.dll"

	static STATUS_SUCCESS              := 0x00000000
	static STATUS_INFO_LENGTH_MISMATCH := 0xC0000004
	static STATUS_BUFFER_TOO_SMALL     := 0xC0000023
	static SYSTEM_PROCESS_INFORMATION  := 0x00000005

	Buf := Buffer(0x0100, 0)
	NT_STATUS := DllCall("ntdll\NtQuerySystemInformation", "Int", SYSTEM_PROCESS_INFORMATION, "Ptr", Buf.Ptr, "UInt", Buf.Size, "UInt*", &amp;Size := 0, "UInt")

	while (NT_STATUS = STATUS_INFO_LENGTH_MISMATCH) || (NT_STATUS = STATUS_BUFFER_TOO_SMALL)
	{
		Buf := Buffer(Size, 0)
		NT_STATUS := DllCall("ntdll\NtQuerySystemInformation", "Int", SYSTEM_PROCESS_INFORMATION, "Ptr", Buf.Ptr, "UInt", Buf.Size, "UInt*", &amp;Size := 0, "UInt")
	}

	if (NT_STATUS = STATUS_SUCCESS)
	{
		PROCESS_INFORMATION := Map()
		Addr := Buf.Ptr
		while (Addr)
		{
			PROCESS := Map()
			PROCESS["NumberOfThreads"]              := NumGet(Addr, 0x0004, "UInt")
			PROCESS["WorkingSetPrivateSize"]        := NumGet(Addr, 0x0008, "Int64")
			PROCESS["HardFaultCount"]               := NumGet(Addr, 0x0010, "UInt")
			PROCESS["NumberOfThreadsHighWatermark"] := NumGet(Addr, 0x0014, "UInt")
			PROCESS["CycleTime"]                    := NumGet(Addr, 0x0018, "UInt64")
			PROCESS["CreateTime"]                   := NumGet(Addr, 0x0020, "Int64")
			PROCESS["UserTime"]                     := NumGet(Addr, 0x0028, "Int64")
			PROCESS["KernelTime"]                   := NumGet(Addr, 0x0030, "Int64")
			PROCESS["ImageName"]                    := (Ptr := NumGet(Addr, 0x0040, "Ptr")) ? StrGet(Ptr) : ""
			PROCESS["BasePriority"]                 := NumGet(Addr, 0x0048, "Int")
			PROCESS["UniqueProcessId"]              := NumGet(Addr, 0x0050, "Ptr")
			PROCESS["InheritedFromUniqueProcessId"] := NumGet(Addr, 0x0058, "Ptr*")
			PROCESS["HandleCount"]                  := NumGet(Addr, 0x0060, "UInt")
			PROCESS["SessionId"]                    := NumGet(Addr, 0x0064, "UInt")
			PROCESS["UniqueProcessKey"]             := NumGet(Addr, 0x0068, "UPtr")
			PROCESS["PeakVirtualSize"]              := NumGet(Addr, 0x0070, "UPtr")
			PROCESS["VirtualSize"]                  := NumGet(Addr, 0x0078, "UPtr")
			PROCESS["PageFaultCount"]               := NumGet(Addr, 0x0080, "UInt")
			PROCESS["PeakWorkingSetSize"]           := NumGet(Addr, 0x0088, "UPtr")
			PROCESS["WorkingSetSize"]               := NumGet(Addr, 0x0090, "UPtr")
			PROCESS["QuotaPeakPagedPoolUsage"]      := NumGet(Addr, 0x0098, "UPtr")
			PROCESS["QuotaPagedPoolUsage"]          := NumGet(Addr, 0x00A0, "UPtr")
			PROCESS["QuotaPeakNonPagedPoolUsage"]   := NumGet(Addr, 0x00A8, "UPtr")
			PROCESS["QuotaNonPagedPoolUsage"]       := NumGet(Addr, 0x00B0, "UPtr")
			PROCESS["PagefileUsage"]                := NumGet(Addr, 0x00B8, "UPtr")
			PROCESS["PeakPagefileUsage"]            := NumGet(Addr, 0x00C0, "UPtr")
			PROCESS["PrivatePageCount"]             := NumGet(Addr, 0x00C8, "UPtr")
			PROCESS["ReadOperationCount"]           := NumGet(Addr, 0x00D0, "Int64")
			PROCESS["WriteOperationCount"]          := NumGet(Addr, 0x00D8, "Int64")
			PROCESS["OtherOperationCount"]          := NumGet(Addr, 0x00E0, "Int64")
			PROCESS["ReadTransferCount"]            := NumGet(Addr, 0x00E8, "Int64")
			PROCESS["WriteTransferCount"]           := NumGet(Addr, 0x00F0, "Int64")
			PROCESS["OtherTransferCount"]           := NumGet(Addr, 0x00F8, "Int64")
			PROCESS_INFORMATION[A_Index]            := PROCESS

			if !(NumGet(Addr, 0x0000, "UInt"))
				break
			Addr += NumGet(Addr, 0x0000, "UInt")
		}
		return PROCESS_INFORMATION
	}

	return false
}</Item>
			<Item name="外框高亮线v2" tv="10205472">
t1 := HighlightOutline(0, 0, 200, 200,,"d21d83", 128)
t1.Show(0, 0, 200, 200)
HighlightOutline(200, 0, 400, 200,,"328ad6", 255, 3000)
loop(3)
{
    Sleep(1000)
    t1.Hide()
    Sleep(1000)
    t1.Show(0, 0, 200, 200)
}
t1.Destroy()

class HighlightOutline 
{
    gui := []
	__New(x1, y1, x2, y2, b := 3,color := "red", Transparent := 255, time_out := unset) 
    {
        this.gui.Length := 4
		Loop 4 {
            this.gui[A_index] := Gui("-Caption +AlwaysOnTop +ToolWindow -DPIScale +E0x20 +E0x00080000")
            this.gui[A_index].BackColor := color
			DllCall("SetLayeredWindowAttributes", "Ptr", this.gui[A_index].hwnd, "Uint", 0, "Uchar", Transparent, "int", 2)
		}
        if(IsSet(time_out))
        {
            this.timer := ObjBindMethod(this, "Destroy")
            this.Show(x1, y1, x2, y2)
            SetTimer(this.timer, -time_out)
        }
	}
	Show(x1, y1, x2, y2, b := 3) 
    {
		Try 
        {
            this.gui[1].Show("NA x" x1-b " y" y1-b " w" x2-x1+b*2 " h" b)
            this.gui[2].show("NA x" x2 " y" y1 " w" b " h" y2-y1)
            this.gui[3].Show("NA x" x1-b " y" y2 " w" x2-x1+2*b " h" b)
            this.gui[4].Show("NA x" x1-b " y" y1 " w" b " h" y2-y1)
		}
	}
	Hide() 
    {
		Loop(4)
        {
            try 
            { 
                this.gui[A_Index].Hide()
            }
        }
	}
	Destroy()
    {
        this.timer := 0
		Loop(4)
        {
            try
            {
                this.gui[A_Index].Destroy()
            }
        }
	}
}</Item>
			<Item name="进程间通信feiyue" tv="10204128">/*
====================================
  talk v1.2 - by Avi Aryan, FeiYue

  Licensed Under MIT License

  使用方法：
  1、两个脚本的开头都包含本库脚本：#Include %A_LineFile%\..\talk.ahk
  2、在一个脚本中新建一个通信对象：aaa := new talk("另一个脚本名")
  3、然后就可以用这个通信对象控制另一个脚本了：F1:: aaa.Pause()
====================================

s=
(%
return
bbb:
Critical
Loop {
  if Mod(A_Index,10)=1
    s:=123
  ToolTip % "111-" s
  Sleep, 100
}
)
talk_exec(s,"111")
aaa:=new talk("111 ahk_class AutoHotkeyGUI")
aaa.runlabel("bbb")
F1:: aaa.setvar("s",456)

*/

/*
Class talk
    Methods
        setvar(varname, value)    -    Set the var in a client script
        getvar(varname)    -    Get the value of var in a client script
        runlabel(label, wait:=0)    -    run a label in a client script
        suspend()    -    suspend a client script
        pause()    -    pause a client script
        reload()    -    reload a client script
        exitapp()    -    exitapp or exits a client script
    Return Values
        Except getvar() which returns the value, all other function returns whether they were successful or not
        Successful = 1
        Communication Request not accepted = 0
        (Client) Script not found = FAIL
*/

class talk {

    __New(WinTitle) {
        this.Script2 := WinTitle
        dhw := A_DetectHiddenWindows, tmm := A_TitleMatchMode
        DetectHiddenWindows On
        SetTitleMatchMode 2
        WinWait, %WinTitle%,, 3
        DetectHiddenWindows %dhw%
        SetTitleMatchMode %tmm%
    }

    wait() {
        lls:=A_ListLines=0 ? "Off" : "On"
        ListLines, Off
        while !talk.return
            sleep, 20
        talk.return := ""
        ListLines, %lls%
    }

    setvar(varname, value) {
        T := talk_send(this.Script2, "setvar", varname, value)
        this.wait()
        return T
    }

    getvar(varname) {
        talk_send(this.Script2, "getvar", varname)
        this.wait()
        return talk.returnValue
    }

    runlabel(label, wait:=0) {
        T := talk_send(this.Script2, "runlabel", label, wait)
        if (wait)
            this.wait()
        return T
    }

    suspend() {
        return talk_send(this.Script2, "suspend")
    }

    pause() {
        return talk_send(this.Script2, "pause")
    }

    reload() {
        return talk_send(this.Script2, "reload")
    }

    exitapp() {
        return talk_send(this.Script2, "exitapp")
    }
}

talk_send(WinTitle, String*) {
    local
    StringToSend:="ahk_id " A_ScriptHwnd "|"
    For k,v in String
        StringToSend.=StrReplace(StrReplace(v,"\","\0"),"|","\1") . "|"
    SizeInBytes := (StrLen(StringToSend) + 1) * (A_IsUnicode ? 2 : 1)
    VarSetCapacity(CopyDataStruct, 3*A_PtrSize, 0)
    NumPut(SizeInBytes, CopyDataStruct, A_PtrSize)
    NumPut(&amp;StringToSend, CopyDataStruct, 2*A_PtrSize)
    dhw := A_DetectHiddenWindows, tmm := A_TitleMatchMode
    DetectHiddenWindows On
    SetTitleMatchMode 2
    SendMessage, 0x4a, 0, &amp;CopyDataStruct,, %WinTitle%
    DetectHiddenWindows %dhw%
    SetTitleMatchMode %tmm%
    return ErrorLevel
}

talk_receive(wParam, lParam) {
    local
    global talk
    static init:=OnMessage(0x4a, Func("talk_receive"))
    static run_label, run_wait, run_script2
    Critical
    ;-- SenderScriptHwnd|Cmd|Data1|Data2
    r:=StrSplit( StrGet( NumGet(lParam+2*A_PtrSize) ), "|")
    Script2:=StrReplace(StrReplace(r[1],"\1","|"),"\0","\")
    Cmd    :=StrReplace(StrReplace(r[2],"\1","|"),"\0","\")
    Data1  :=StrReplace(StrReplace(r[3],"\1","|"),"\0","\")
    Data2  :=StrReplace(StrReplace(r[4],"\1","|"),"\0","\")
    if (Cmd="return")
    {
        talk.return := 1, talk.returnValue := Data2
        return
    }
    else if (Cmd="setvar")
    {
        talk_setvar(Data1, Data2)
        talk_send(Script2, "return", "setvar")
        return
    }
    else if (Cmd="getvar")
    {
        talk_send(Script2, "return", "getvar", talk_getvar(Data1))
        return
    }
    else if (Cmd="runlabel")
    {
        run_label:=Data1, run_wait:=Data2, run_script2:=Script2
        SetTimer, talk_runlabel, -1
        return
        talk_runlabel:
        if IsLabel(run_label)
            Gosub, %run_label%
        if (run_wait)
            talk_send(run_script2, "return", "runlabel")
        return
    }
    else if (Cmd="suspend")
    {
        Suspend
        return
    }
    else if (Cmd="pause")
    {
        Pause,, 1
        return
    }
    else if (Cmd="reload")
    {
        Reload
        Sleep, 1000
        return
    }
    else if (Cmd="exitapp")
    {
        ExitApp
        return
    }
}

talk_setvar(___varname___, ByRef ___value___) {
    global
    Try %___varname___% := ___value___
}

talk_getvar(___varname___) {
    global
    Try return (%___varname___%)
}

talk_exec(script, title:="") {
    local
    s1:="`n title=" . title
    . "`n #NoEnv"
    . "`n; #NoTrayIcon"
    . "`n Suspend, On"
    . "`n SetTitleMatchMode, 2"
    . "`n DetectHiddenWindows, On"
    . "`n Gui, Gui_Title_Gui: Show, Hide, &lt;&lt;%title%&gt;&gt;"
    . "`n Gui, Gui_Title_Gui: +Hwndmyid"
    . "`n WinGet, list, List, &lt;&lt;%title%&gt;&gt; ahk_class AutoHotkeyGUI"
    . "`n Loop, % list {"
    . "`n     IfEqual, myid, % id:=list%A_Index%, Continue"
    . "`n     WinGet, pid, PID, ahk_id %id%"
    . "`n     WinClose, ahk_pid %pid% ahk_class AutoHotkey,, 2"
    . "`n     IfWinExist, ahk_id %id%,, Process, Close, %pid%"
    . "`n }"
    FileRead, s2, %A_LineFile%
    s2:=RegExReplace(s2,"i)^[\s\S]*?(?=class talk {\s)")
    script:=RegExReplace(s1 "`n" script "`nExitApp`n" s2,"\R","`r`n")
    ;-------------------------
    shell:=ComObjCreate("WScript.Shell")
    exec:=shell.Exec(A_AhkPath " /f *")
    exec.StdIn.Write(script)
    exec.StdIn.Close()
}
</Item>
			<Item name="feiyue正则匹配所有结果" tv="10205808">
str := "aaa123===bbb456"
re := "([ab]+)(\d+)"
For k,v in arr:=RegExMatchAll(str, re)
  msgbox % "第 " k " 个匹配的第 2 个子匹配是：" v[2]

;----------------------------------
; 简单的 RegExMatchAll  By FeiYue
;----------------------------------
; 返回值为所有找到的匹配的二级数组，没找到返回0
; 第一级是所有找到的匹配
; 第二级是每个找到的匹配的多个字符串构成的简单数组
;     数组[0]表示整个匹配的字符串
;     数组[N]表示第N个子模式匹配的字符串
;----------------------------------
RegExMatchAll(str, re)
{
  ; 给正则表达式re添加大欧选项O)
  re:=RegExMatch(re, "^[\w\s`a]*\)") ? "O" re : "O)" re
  arr:=[], pos:=1
  While pos:=RegExMatch(str, re, Match, pos)
  {
    if Match.Len(0)&lt;1 and (pos++ or 1)
      Continue
    pos+=Match.Len(0), arr2:=[]
    Loop % Floor(Match.Count())+1
      arr2[A_Index-1]:=Match.Value(A_Index-1)
    arr.Push(arr2)
  }
  return arr.Length() ? arr : 0
}
</Item>
			<Item name="正则匹配技巧1" tv="10207712">; 用高级方法获取&lt;a&gt;...&lt;/a&gt;之间的内容

s:="&lt;a&gt;aaaaaaaaa&lt;/a&gt; &lt;a&gt;bbbbbbbb&lt;/a&gt;"

; 错误方法：贪婪的任意字符会得到多余内容
re:="&lt;a&gt;([\s\S]*)&lt;/a&gt;"
RegExMatch(s, re, r)
MsgBox, % r1

; 简单方法：非贪婪的任意字符得到最少内容
re:="&lt;a&gt;([\s\S]*?)&lt;/a&gt;"
RegExMatch(s, re, r)
MsgBox, % r1

; 高级方法：后面没有接&lt;/a&gt;的任意字符
re:="&lt;a&gt;((?:(?!&lt;/a&gt;)[\s\S])*)&lt;/a&gt;"
RegExMatch(s, re, r)
MsgBox, % r1</Item>
			<Item name="单进程运行函数feiyue" tv="10205024">;-----------------------------
;  单进程运行函数  By FeiYue
;
;  用法：把本函数丢到任何脚本中，设定标记即可（修改001）
;-----------------------------

; 例子：同时启动10个本脚本，只会保留1个进程
#SingleInstance Off
MsgBox, 4096,, % A_Now
return

;-- 单进程运行函数  By FeiYue
OnlyOne(flag="") {
  static init:=OnlyOne("001")
  DetectHiddenWindows, % (bak:=A_DetectHiddenWindows) ? "On":"On"
  mypid:=DllCall("GetCurrentProcessId")
  flag:="Ahk_OnlyOne_Ahk&lt;&lt;" . flag . "&gt;&gt;"
  Gui, Ahk_OnlyOne_Ahk: Show, Hide, %flag%
  WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  Loop, % list
  IfWinExist, % "ahk_id " . list%A_Index%
  {
    WinGet, pid, PID
    IfEqual, pid, %mypid%, Continue
    WinClose, ahk_pid %pid% ahk_class AutoHotkey,, 3
    IfWinNotExist,,, Continue
    Process, Close, %pid%
    WinWaitClose
  }
  WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  IfNotEqual, list, 1, ExitApp
  DetectHiddenWindows, %bak%
}
</Item>
			<Item name="获取IP板卡等" tv="10204464">obj:=[],result:=""
obj.InsertAt(1,ComInfo.GetIPAPI_2(),ComInfo.GetMacAddress_1(),ComInfo.GetIPAddress_1(),ComInfo.GetSNCode(),[ComInfo.GetCpuID_3()])
for Section,element In obj
{
	Info:=""
	for key,value in element
	{
		if IsObject(value){
			Loop,% ObjLength(value)
				Info.=value[A_Index] " "
		}Else
			Info.=value " "
	}
	result.=Trim(Info) "`r`n"
}
MsgBox % result
Class ComInfo
{
	/*
		;http://pv.sohu.com/cityjson?ie=utf-8
		    ;返回值{"cip":"xxx","cid":"xxx","cname":"xxx"}
		    ;cip：ip地址
		    ;cid：邮编
		    ;cname：归属地
		;能获取外网ip的接口：
		;http://members.3322.org/dyndns/getip    ;直接返回ip
		;https://api.ipify.org/    ;直接返回ip
		;http://icanhazip.com/    ;直接返回ip
		;http://ident.me/    ;直接返回ip
		;http://ip.cip.cc/    ;直接返回ip
		;http://ip.qaros.com/    ;直接返回ip
		;https://api.ip.sb/ip    ;直接返回ip
		;http://ip.3322.net/    ;直接返回ip
		;http://ip.42.pl/raw    ;直接返回ip
		;https://www.fbisb.com/ip.php
		;http://myip.ipip.net/json    ;返回json格式参数如下：
			{"ret":"ok"
			,"data":
				{"ip":"59.173.134.130"
				,"location":["中国","xx省","xx","","电信"]}}
		;http://ip-api.com/json/?fields=520191&amp;lang=zh-CN    ;返回json格式参数如下:
			{"status":"success","country":"中国"
			,"countryCode":"CN","region":"HB"
			,"regionName":"xx省","city":"xx市"
			,"zip":"","lat":30.5856,"lon":114.2665
			,"timezone":"Asia/Shanghai","isp":"Chinanet"
			,"org":"Chinanet HB","as":"AS4134 CHINANET-BACKBONE"
			,"mobile":false,"proxy":false,"accuracy":10
			,"query":"171.113.255.124"
		;https://api.ttt.sh/ip/qqwry/    返回json格式参数如下：
			{"code":200,"ip":"171.113.255.124"
			,"address":"\u6e56\u5317\u7701 \u7535\u4fe1"
			,"date":"2020-06-23 10:09:40"}
		;http://whois.pconline.com.cn/ipJson.jsp?json=true    返回json格式参数如下：
			{"ip":"171.113.255.124","pro":"xx省"
			,"proCode":"420000","city":"xx市"
			,"cityCode":"420100","region":""
			,"regionCode":"0","addr":"xx省xx市 电信"
			,"regionNames":"","err":""}
	*/
	;获取本机外网IP①
	GetIPAPI(url:="http://pv.sohu.com/cityjson?ie=utf-8") {
		/*
		;	;~ 测试网络连接
		;	if(!DllCall("Wininet.dll\InternetCheckConnection", "Ptr", &amp;Url, "UInt", 0x1, "UInt", 0x0, "Int"))
		;		return []
		;	iHTTP := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		;	iHTTP.Open("Get", URL , False)
		;	iHTTP.SetRequestHeader("User-Agent", "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)")
		;	iHTTP.SetRequestHeader("Referer", URL)
		;	iHTTP.SetRequestHeader("Content-Type", "application/x-www-form-urlencoded")
		;	iHTTP.Send()
		;	RegExMatch(iHTTP.ResponseText,"\{.+\}",ipobj)   ;iHTTP.ResponseText为接收的结果
		;	iJson:= Json_toObj(ipobj)
		;	return [ iJson["cip"], iJson["cname"],"〔 " iJson["cname"] " 〕"]
		*/
		if ipobj:=this.UrlDownloadToVars(url,,,,,,,,,3){   ;设定超时时长
			RegExMatch(ipobj,"\{.+\}",obj)
			iJson:= Json_toObj(obj)
			return [ iJson["cip"],"〔 " iJson["cname"] " 〕"]
		}
	}
	;获取本机外网IP②
	GetIPAPI_1(url:="http://myip.ipip.net/json") {
		if ipobj:=this.UrlDownloadToVars(url,,,,,,,,,3){   ;设定超时时长
			iJson:= Json_toObj(ipobj)
			ipLocal:= iJson["data","location"][1] iJson["data","location"][2] iJson["data","location"][3] iJson["data","location"][5]
			return [ iJson["data","ip"]," 〔 " ipLocal " 〕"]
		}
	}
	;获取本机外网IP③
	GetIPAPI_2(url:="http://whois.pconline.com.cn/ipJson.jsp?json=true") {
		if ipobj:=this.UrlDownloadToVars(url,,,,,,,,,3){   ;设定超时时长
			iJson:= Json_toObj(ipobj)
			ipLocal:= iJson["pro"] iJson["city"] "-" iJson["addr"]
			return [ iJson["ip"]," 〔 " ipLocal " 〕"]
		}
	}
	;获取本机外网IP④
	GetIPAPI_3(url:="https://api.ttt.sh/ip/qqwry/") {
		if ipobj:=this.UrlDownloadToVars(url,,,,,,,,,3){   ;设定超时时长
			iJson:= Json_toObj(ipobj)
			return [ iJson["ip"]," 〔 " iJson["address"] " 〕"]
		}
	}
	;获取设备型号
	GetMacName(){
		;https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-computersystemproduct
		objWMIService := ComObjGet("winmgmts:{impersonationLevel=impersonate}!\\" . "." . "\root\cimv2")
		colSysProduct := objWMIService.ExecQuery("Select * From Win32_ComputerSystemProduct")._NewEnum
		while,colSysProduct[objSysProduct]   ;PropertyList&gt;&gt;["Caption,Description,IdentifyingNumber,Name,SKUNumber,UUID,Vendor,Version"]
		{
			return [objSysProduct["Name"]," 〔 设备品牌型号 〕"]
		}
	}
	;获取网卡物理地址
	GetMacAddress(){
		;https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-networkadapterconfiguration
		NetworkConfiguration:=ComObjGet("Winmgmts:").InstancesOf("Win32_NetworkAdapterConfiguration")
		for mo in NetworkConfiguration
		{
			if(mo.IPEnabled &lt;&gt; 0)
				return mo.MacAddress
		}
	}
	;获取网卡物理地址
	GetMacAddress_1(){
		Adlist:=[], info:=this.GetAdaptersInfo()
		for index, obj in info
		{
			if (not obj["Description"] ~="i)Adapter"||obj["Description"] ~="i)Wifi|wlan"){
				Adlist.Push([obj["Address"] ," 〔" obj["Description"] "〕"])
			}
		}
		return Adlist
	}
	;获取IP地址
	GetIPAddress_1(){
		Adlist:=[], info:=this.GetAdaptersInfo()
		for index, obj in info
		{
			if (not obj["Description"] ~="i)Adapter"&amp;&amp;obj["IpAddressList"]&lt;&gt;"0.0.0.0"||obj["Description"] ~="i)Wifi|wlan"&amp;&amp;obj["IpAddressList"]&lt;&gt;"0.0.0.0")
				Adlist.Push([obj["IpAddressList"] ," 〔" . obj["Description"] . "〕"])
		}
		return Adlist
	}
	;获取CPU串号
	GetCpuID_1(){
		;https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-processor
		objSWbemObject:=ComObjGet("winmgmts:Win32_Processor.DeviceID='cpu0'")
		return objSWbemObject.ProcessorId
	}
	;获取CPU串号
	GetCpuID_3(){
		;https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-processor
		objWMIService := ComObjGet("winmgmts:{impersonationLevel=impersonate}!\\" . A_ComputerName . "\root\cimv2")
		colCPU := objWMIService.ExecQuery("Select * From Win32_Processor")._NewEnum
		While colCPU[objCPU]
			return objCPU["ProcessorId"]    ;Name获取cpu名称
	}
	;获取系统版本信息
	GetOSVersionInfo()
	{
		;https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-operatingsystem?redirectedfrom=MSDN
		osobj := ComObjGet("winmgmts:").ExecQuery("Select * from Win32_OperatingSystem" )._NewEnum()
		if osobj[win]
			return [win.Caption,win.Version,win.Version]
	}
	;返回当前电脑BIOS里的SN机器码
	GetSNCode(){
		;https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-bios
		objWMIService := ComObjGet("winmgmts:{impersonationLevel=impersonate}!\\" . "." . "\root\cimv2")
		colSettings := objWMIService.ExecQuery("Select * from Win32_BIOS")._NewEnum
		While colSettings[objBiosItem]
			return [objBiosItem.SerialNumber ," 〔 设备S/N序列号 〕"]
	}
	;返回当前电脑BIOS里的SN机器码
	GetSNCode_1(){
		;https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-computersystemproduct
		objWMIService := ComObjGet("winmgmts:{impersonationLevel=impersonate}!\\" . "." . "\root\cimv2")
		colSysProduct := objWMIService.ExecQuery("Select * From Win32_ComputerSystemProduct")._NewEnum
		while,colSysProduct[objSysProduct]   ;PropertyList&gt;&gt;["Caption,Description,IdentifyingNumber,Name,SKUNumber,UUID,Vendor,Version"]
		{
			return [objSysProduct["IdentifyingNumber"] ," 〔 设备S/N序列号 〕"]
		}
	}
	;获取网卡mac地址
	GetAdaptersInfo(){
		; 对GetAdaptersInfo的初始调用以获取所需的大小
		if (DllCall("iphlpapi.dll\GetAdaptersInfo", "ptr", 0, "UIntP", size) = 111) ; ERROR_BUFFER_OVERFLOW
			if !(VarSetCapacity(buf, size, 0))  ; size ==&gt;  1x = 704  |  2x = 1408  |  3x = 2112
				return "IP适配器信息结构的内存分配失败！"
		; 第二次调用GetAdapters地址以获取我们想要的实际数据
		if (DllCall("iphlpapi.dll\GetAdaptersInfo", "ptr", &amp;buf, "UIntP", size) != 0) ; NO_ERROR / ERROR_SUCCESS
			return "调用GetAdaptersInfo失败，ERROR: " A_LastError
		; 从数据中获取信息
		addr := &amp;buf, IP_ADAPTER_INFO := {}
		while (addr)
		{
			IP_ADAPTER_INFO[A_Index, "ComboIndex"]:= NumGet(addr+0, o := A_PtrSize, "UInt"), o += 4
			IP_ADAPTER_INFO[A_Index, "AdapterName"]:= StrGet(addr+0 + o, 260, "CP0"), o += 260
			IP_ADAPTER_INFO[A_Index, "Description"]:= StrGet(addr+0 + o, 132, "CP0"), o += 132
			IP_ADAPTER_INFO[A_Index, "AddressLength"]:= NumGet(addr+0, o, "UInt"), o += 4
			loop % IP_ADAPTER_INFO[A_Index].AddressLength
				mac .= Format("{:02X}",NumGet(addr+0, o + A_Index - 1, "UChar")) "-"
			IP_ADAPTER_INFO[A_Index, "Address"]:= SubStr(mac, 1, -1), mac := "", o += 8
			IP_ADAPTER_INFO[A_Index, "Index"]:= NumGet(addr+0, o, "UInt"), o += 4
			IP_ADAPTER_INFO[A_Index, "Type"]:= NumGet(addr+0, o, "UInt"), o += 4
			IP_ADAPTER_INFO[A_Index, "DhcpEnabled"]:= NumGet(addr+0, o, "UInt"), o += A_PtrSize
			Ptr := NumGet(addr+0, o, "UPtr"), o += A_PtrSize
			IP_ADAPTER_INFO[A_Index, "CurrentIpAddress"]:= Ptr ? StrGet(Ptr + A_PtrSize, "CP0") : ""
			IP_ADAPTER_INFO[A_Index, "IpAddressList"]:= StrGet(addr + o + A_PtrSize, "CP0")
			;~ IP_ADAPTER_INFO[A_Index, "IpMaskList"]:= StrGet(addr + o + A_PtrSize + 16, "CP0") , o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "IpMaskList"]:= StrGet(addr + o + A_PtrSize * 3, "CP0") , o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "GatewayList"]:= StrGet(addr + o + A_PtrSize, "CP0"), o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "DhcpServer"]:= StrGet(addr + o + A_PtrSize, "CP0"), o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "HaveWins"]:= NumGet(addr+0, o, "Int"), o += A_PtrSize
			IP_ADAPTER_INFO[A_Index, "PrimaryWinsServer"]:= StrGet(addr + o + A_PtrSize, "CP0"), o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "SecondaryWinsServer"] := StrGet(addr + o + A_PtrSize, "CP0"), o += A_PtrSize + 32 + A_PtrSize
			IP_ADAPTER_INFO[A_Index, "LeaseObtained"]:= this.DateAdd(NumGet(addr+0, o, "Int")), o += A_PtrSize
			IP_ADAPTER_INFO[A_Index, "LeaseExpires"]:= this.DateAdd(NumGet(addr+0, o, "Int"))
			addr := NumGet(addr+0, "UPtr")
		}
		; 输出数据并释放缓冲区
		return IP_ADAPTER_INFO, VarSetCapacity(buf, 0), VarSetCapacity(addr, 0)
	}
	;~ *****************说明*****************
	;~ 此函数与内置命令 UrlDownloadToFile 的区别有以下几点
	;~ 1.直接下载到变量，没有临时文件
	;~ 2.下载速度更快，大概100%
	;~ 3.支持超时，不必死等
	;~ 4.内置命令执行时，整个AHK程序都是卡顿状态。此函数不会
	;~ 5.内置命令下载一些诡异网站（例如“牛杂网”）时，会概率性让进程或线程彻底死掉。此函数不会
	;~ 6.支持设置网页字符集、URL的编码，乱码问题轻松解决
	;~ 7.支持设置Cookie、Referer、User-Agent，网站检测问题轻松解决
	;~ 8.支持设置代理服务器
	;~ 9.支持设置是否开启重定向
	;~ 10.这个版本是 0.5
	;~ *****************参数*****************
	;~ URL 网址，必须包含类似“http://www.”的开头。
	;~ Charset 网页字符集，不能是“936”之类的数字，必须是“gb2312”这样的字符。
	;~ URLCodePage URL的编码，是“936”之类的数字，默认是“65001”。有些网站需要UTF-8，有些网站又需要gb2312
	;~ Proxy 代理服务器，是形如“http://www.tuzi.com:80”的字符。
	;~ ProxyBypassList 代理服务器绕行名单，是形如“*.microsoft.com”的域名。符合域名的网址，将不通过代理服务器访问。
	;~ Cookie ，常用于登录验证。
	;~ Referer 引用网址，常用于防盗链。
	;~ UserAgent 用户信息，常用于防盗链。
	;~ EnableRedirects 重定向，默认获取跳转后的页面信息，0为不跳转。
	;~ Timeout 超时，单位为秒，默认不使用超时（Timeout=-1）。
	UrlDownloadToVars(URL,Charset="",URLCodePage="",Proxy="",ProxyBypassList="",Cookie="",Referer="",UserAgent="",EnableRedirects="",Timeout=-1)
	{
		ComObjError(0)  ;禁用 COM 错误通告。禁用后，检查 A_LastError 的值，脚本可以实现自己的错误处理
		WebRequest := ComObjCreate("WinHttp.WinHttpRequest.5.1")
		if (URLCodePage&lt;&gt;"")    ;设置URL的编码
			WebRequest.Option(2):=URLCodePage
		if (EnableRedirects&lt;&gt;"")
			WebRequest.Option(6):=EnableRedirects
		if (Proxy&lt;&gt;"")  ;设置代理服务器。微软的代码 SetProxy() 是放在 Open() 之前的，所以我也放前面设置，以免无效
			WebRequest.SetProxy(2,Proxy,ProxyBypassList)
		WebRequest.Open("GET", URL, true)   ;true为异步获取，默认是false。龟速的根源！！！卡顿的根源！！！
		if (Cookie&lt;&gt;"") ;设置Cookie。SetRequestHeader() 必须 Open() 之后才有效
		{
			WebRequest.SetRequestHeader("Cookie","tuzi")    ;先设置一个cookie，防止出错，见官方文档
			WebRequest.SetRequestHeader("Cookie",Cookie)
		}
		if (Referer&lt;&gt;"")    ;设置Referer
			WebRequest.SetRequestHeader("Referer",Referer)
		if (UserAgent&lt;&gt;"")  ;设置User-Agent
			WebRequest.SetRequestHeader("User-Agent",UserAgent)
		WebRequest.Send()
		WebRequest.WaitForResponse(Timeout) ;WaitForResponse方法确保获取的是完整的响应
		if (Charset="") ;设置字符集
			return,RegExReplace(WebRequest.ResponseText(),"^\s+|\s+$")
		else
		{
			ADO:=ComObjCreate("adodb.stream")   ;使用 adodb.stream 编码返回值。参考 http://bbs.howtoadmin.com/ThRead-814-1-1.html
			ADO.Type:=1 ;以二进制方式操作
			ADO.Mode:=3 ;可同时进行读写
			ADO.Open()  ;开启物件
			ADO.Write(WebRequest.ResponseBody())    ;写入物件。注意 WebRequest.ResponseBody() 获取到的是无符号的bytes，通过 adodb.stream 转换成字符串string
			ADO.Position:=0 ;从头开始
			ADO.Type:=2 ;以文字模式操作
			ADO.Charset:=Charset    ;设定编码方式
			return,RegExReplace(ADO.ReadText(),"^\s+|\s+$")   ;将物件内的文字读出
		}
	}
	DateAdd(time)
	{
		if (time = 0)
			return 0
		datetime := 19700101
		datetime += time, s
		FormatTime, OutputVar, datetime, yyyy-MM-dd HH:mm:ss
		return OutputVar
	}
}
Json_toObj(ByRef src, args*)
{
	static q := Chr(34)
	key := "", is_key := false
	stack := [ tree := [] ]
	is_arr := { (tree): 1 }
	next := q . "{[01234567890-tfn"
	pos := 0
	while ( (ch := SubStr(src, ++pos, 1)) != "" )
	{
		if InStr(" `t`n`r", ch)
			continue
		if !InStr(next, ch, true)
		{
			ln := ObjLength(StrSplit(SubStr(src, 1, pos), "`n"))
			col := pos - InStr(src, "`n",, -(StrLen(src)-pos+1))
			msg := Format("{}: line {} col {} (char {})"
			,   (next == "")      ? ["Extra data", ch := SubStr(src, pos)][1]
			  : (next == "'")     ? "Unterminated string starting at"
			  : (next == "\")     ? "Invalid \escape"
			  : (next == ":")     ? "Expecting ':' delimiter"
			  : (next == q)       ? "Expecting object key enclosed in double quotes"
			  : (next == q . "}") ? "Expecting object key enclosed in double quotes or object closing '}'"
			  : (next == ",}")    ? "Expecting ',' delimiter or object closing '}'"
			  : (next == ",]")    ? "Expecting ',' delimiter or array closing ']'"
			  : [ "Expecting JSON value(string, number, [true, false, null], object or array)"
			    , ch := SubStr(src, pos, (SubStr(src, pos)~="[\]\},\s]|$")-1) ][1]
			, ln, col, pos)
			throw Exception(msg, -1, ch)
		}
		is_array := is_arr[obj := stack[1]]
		if i := InStr("{[", ch)
		{
			val := (proto := args[i]) ? new proto : {}
			is_array? ObjPush(obj, val) : obj[key] := val
			ObjInsertAt(stack, 1, val)
			is_arr[val] := !(is_key := ch == "{")
			next := q . (is_key ? "}" : "{[]0123456789-tfn")
		}
		else if InStr("}]", ch)
		{
			ObjRemoveAt(stack, 1)
			next := stack[1]==tree ? "" : is_arr[stack[1]] ? ",]" : ",}"
		}
		else if InStr(",:", ch)
		{
			is_key := (!is_array &amp;&amp; ch == ",")
			next := is_key ? q : q . "{[0123456789-tfn"
		}
		else ; string | number | true | false | null
		{
			if (ch == q) ; string
			{
				i := pos
				while i := InStr(src, q,, i+1)
				{
					val := StrReplace(SubStr(src, pos+1, i-pos-1), "\\", "\u005C")
					static end := A_AhkVersion&lt;"2" ? 0 : -1
					if (SubStr(val, end) != "\")
						break
				}
				if !i ? (pos--, next := "'") : 0
					continue
				pos := i ; update pos
				  val := StrReplace(val,    "\/",  "/")
				, val := StrReplace(val, "\" . q,    q)
				, val := StrReplace(val,    "\b", "`b")
				, val := StrReplace(val,    "\f", "`f")
				, val := StrReplace(val,    "\n", "`n")
				, val := StrReplace(val,    "\r", "`r")
				, val := StrReplace(val,    "\t", "`t")
				i := 0
				while i := InStr(val, "\",, i+1)
				{
					if (SubStr(val, i+1, 1) != "u") ? (pos -= StrLen(SubStr(val, i)), next := "\") : 0
						continue 2
					; \uXXXX - JSON unicode escape sequence
					xxxx := Abs("0x" . SubStr(val, i+2, 4))
					if (A_IsUnicode || xxxx &lt; 0x100)
						val := SubStr(val, 1, i-1) . Chr(xxxx) . SubStr(val, i+6)
				}
				if is_key
				{
					key := val, next := ":"
					continue
				}
			}
			else ; number | true | false | null
			{
				val := SubStr(src, pos, i := RegExMatch(src, "[\]\},\s]|$",, pos)-pos)
				static null := "" ; for #Warn
				if InStr(",true,false,null,", "," . val . ",", true) ; if var in
					val := %val%
				else if (Abs(val) == "") ? (pos--, next := "#") : 0
					continue
				val := val + 0, pos += i-1
			}
			is_array? ObjPush(obj, val) : obj[key] := val
			next := obj==tree ? "" : is_array ? ",]" : ",}"
		}
	}
	return tree[1]
}</Item>
			<Item name="二进制转字符串v2" tv="10206704">#include &lt;log&gt;
b := NumGet(strptr(Chr(0xfce1 &amp; 0xffff)), 0, "Short")
MsgBox cast('ushort',0xfce1,'short')
logger.info(b)

CryptStringToBinary(str, flag){
	DllCall("crypt32\CryptStringToBinaryW", "str", str, "uint", StrLen(str), "uint", flag, "ptr", 0, "uint*", &amp;bytes := 0, "ptr", 0, "ptr", 0)
	DllCall("crypt32\CryptStringToBinaryW", "str", str, "uint", StrLen(str), "uint", flag, "ptr", bin := Buffer(bytes), "uint*", bytes, "ptr", 0, "ptr", 0)
	return bin
}
; https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringw
CryptBinaryToString(bin, flag){
	DllCall("crypt32\CryptBinaryToStringW", "ptr", bin, "uint", bin.Size, "uint", flag, "ptr", 0, "uint*", &amp;cnt := 0)
	DllCall("crypt32\CryptBinaryToStringW", "ptr", bin, "uint", bin.Size, "uint", flag, "ptr", str := Buffer(cnt * 2), "uint*", cnt)
	return StrGet(str)
}

bin := FileRead(A_ScriptFullPath, "raw")
str := CryptBinaryToString(bin, 0x00000004 | 0x40000000)
logger.info(str)
str := RegExReplace(str, "61 61 61 61 61", "62 62 62 62 62")
bin := CryptStringToBinary(str, 4)
FileAppend(bin, "out.ah2", "raw")</Item>
			<Item name="进制转换" tv="10207152">; 进制转换
ConvertBase(InputBase, OutputBase, nptr){    ; Base 2 - 36
	static u := A_IsUnicode ? "_wcstoui64" : "_strtoui64"
	static v := A_IsUnicode ? "_i64tow" : "_i64toa"
	VarSetCapacity(s, 66, 0)
	value := DllCall("msvcrt.dll\" u, "Str", nptr, "UInt", 0, "UInt", InputBase, "CDECL Int64")
	DllCall("msvcrt.dll\" v, "Int64", value, "Str", s, "UInt", OutputBase, "CDECL")
	return s
}
</Item>
			<Item name="脚本通讯feiyue" tv="10204688">;---------------------------------------
; 多个脚本间的简单通讯 v1.0  By FeiYue
;
; 使用方法：
; 1、各个脚本在脚本开头用 Say_Set(通讯号码) 设置自身通讯号码
; 2、各个脚本用 Say(要说的话, 通讯号码) 互相发送字符串
; 3、各个脚本在 Say_Get(s) 中处理收到的字符串，默认为显示
;---------------------------------------

; 下面是启动三个进程代替三个脚本互相通讯的例子

进程1代码 =
(` %

Say_Set(1)  ; 设置自身通讯号码为1
return

F3:: Say("1号对0号说话", 0)

;===== 下面是通讯函数 =====

Say_Get(s) {
  A_Args.s:=s  ; 保存到全局变量，可以在其他函数中使用
  MsgBox, 4096,, % s
}

Say(s, number) {
  DetectHiddenWindows, On
  number:=Format("{:d}", number)
  IfWinExist, Say[%number%] ahk_class AutoHotkeyGUI
  {
    ControlSetText,, %s%
    Critical, % (cri:=A_IsCritical)?"On":"On"
    WinClose
    Critical, %cri%
  }
}

Say_Set(number, args*) {
  if (number="WM_Close")
  {
    Critical
    if (A_Gui="Say_Gui")
    {
      WinMenuSelectItem,,, 1&amp;
      return 1
    }
  }
  else if (number="Menu_Go")
  {
    ControlGetText, s
    Say_Get(s)
  }
  else
  {
    Gui, Say_Gui: +LastFoundExist
    IfWinNotExist
    {
      r:=Func(A_ThisFunc).Bind("Menu_Go")
      Menu, Say_Gui_Menu, Add, Go, %r%
      Gui, Say_Gui: Add, Edit
      Gui, Say_Gui: Menu, Say_Gui_Menu
      OnMessage(0x10, Func(A_ThisFunc).Bind("WM_Close"))
    }
    number:=Format("{:d}", number)
    Gui, Say_Gui: Show, Hide, Say[%number%]
  }
}

)

进程2代码 =
(` %

Say_Set(2)  ; 设置自身通讯号码为2
return

F4:: Say("2号对0号说话", 0)

;===== 下面是通讯函数 =====

Say_Get(s) {
  A_Args.s:=s  ; 保存到全局变量，可以在其他函数中使用
  MsgBox, 4096,, % s
}

Say(s, number) {
  DetectHiddenWindows, On
  number:=Format("{:d}", number)
  IfWinExist, Say[%number%] ahk_class AutoHotkeyGUI
  {
    ControlSetText,, %s%
    Critical, % (cri:=A_IsCritical)?"On":"On"
    WinClose
    Critical, %cri%
  }
}

Say_Set(number, args*) {
  if (number="WM_Close")
  {
    Critical
    if (A_Gui="Say_Gui")
    {
      WinMenuSelectItem,,, 1&amp;
      return 1
    }
  }
  else if (number="Menu_Go")
  {
    ControlGetText, s
    Say_Get(s)
  }
  else
  {
    Gui, Say_Gui: +LastFoundExist
    IfWinNotExist
    {
      r:=Func(A_ThisFunc).Bind("Menu_Go")
      Menu, Say_Gui_Menu, Add, Go, %r%
      Gui, Say_Gui: Add, Edit
      Gui, Say_Gui: Menu, Say_Gui_Menu
      OnMessage(0x10, Func(A_ThisFunc).Bind("WM_Close"))
    }
    number:=Format("{:d}", number)
    Gui, Say_Gui: Show, Hide, Say[%number%]
  }
}

)

进程1:= new Thread(进程1代码)
进程2:= new Thread(进程2代码)

Say_Set(0)  ; 设置自身通讯号码为0
return

F1:: Say("0号对1号说话", 0)

F2:: Say("0号对2号说话", 2)

;===== 下面是通讯函数 =====

Say_Get(s) {
  A_Args.s:=s  ; 保存到全局变量，可以在其他函数中使用
  MsgBox, 4096,, % s
}

Say(s, number) {
  DetectHiddenWindows, On
  number:=Format("{:d}", number)
  IfWinExist, Say[%number%] ahk_class AutoHotkeyGUI
  {
    ControlSetText,, %s%
    Critical, % (cri:=A_IsCritical)?"On":"On"
    WinClose
    Critical, %cri%
  }
}

Say_Set(number, args*) {
  if (number="WM_Close")
  {
    Critical
    if (A_Gui="Say_Gui")
    {
      WinMenuSelectItem,,, 1&amp;
      return 1
    }
  }
  else if (number="Menu_Go")
  {
    ControlGetText, s
    Say_Get(s)
  }
  else
  {
    Gui, Say_Gui: +LastFoundExist
    IfWinNotExist
    {
      r:=Func(A_ThisFunc).Bind("Menu_Go")
      Menu, Say_Gui_Menu, Add, Go, %r%
      Gui, Say_Gui: Add, Edit
      Gui, Say_Gui: Menu, Say_Gui_Menu
      OnMessage(0x10, Func(A_ThisFunc).Bind("WM_Close"))
    }
    number:=Format("{:d}", number)
    Gui, Say_Gui: Show, Hide, Say[%number%]
  }
}

Say_Test(number) {
  DetectHiddenWindows, On
  number:=Format("{:d}", number)
  WinGet, id, ID, Say[%number%] ahk_class AutoHotkeyGUI
  return (id ? 1:0)
}

;===== 下面是多进程类 =====

Class Thread {
  __New(args*) {
    this.pid:=this.Exec(args*)
  }
  __Delete() {
    pid:=this.pid
    DetectHiddenWindows, On
    IfWinExist, ahk_class AutoHotkey ahk_pid %pid%
    {
      PostMessage, 0x111, 65307
      WinWaitClose,,, 0.5
      IfEqual, ErrorLevel, 1, Process, Close, %pid%
    }
  }
  Exec(s, Ahk:="", args:="") {
    Ahk:=Ahk ? Ahk:A_IsCompiled ? A_ScriptDir "\AutoHotkey.exe":A_AhkPath
    s:="DllCall(""SetWindowText"",""Ptr"",A_ScriptHwnd,""Str"",""&lt;AHK&gt;"")`n"
      . StrReplace(s,"`r")
    Try {
      shell:=ComObjCreate("WScript.Shell")
      oExec:=shell.Exec("""" Ahk """ /force * " args)
      oExec.StdIn.Write(s)
      oExec.StdIn.Close(), pid:=oExec.ProcessID
    }
    Catch {
      f:=A_Temp "\~ahk.tmp"
      s:="`n FileDelete, " f "`n" s
      FileDelete, %f%
      FileAppend, %s%, %f%
      r:=this.Clear.Bind(this)
      SetTimer, %r%, -3000
      Run, "%Ahk%" /force "%f%" %args%,, UseErrorLevel, pid
    }
    return pid
  }
  Clear() {
    FileDelete, % A_Temp "\~ahk.tmp"
    SetTimer,, Off
  }
}
</Item></Item>
		<Item name="例子" tv="10204576">
			<Item name="scp顺序更新" tv="10204800">噜啦噜啦嘞</Item>
			<Item name="文本转图片" tv="10205248">run,https://github.com/halodong/codeImg
run,https://github.com/MisaLiu/Text2Image</Item>
			<Item name="文本转图片bitmap" tv="10207264">run,https://blog.csdn.net/jacky_qiu/article/details/6094622</Item>
			<Item name="双缓冲" tv="10204016">Gui, -0x400000 +Border ;WS_DLGFRAME WS_BORDER(细边框)  caption(标题栏和粗边框) = WS_DLGFRAME+WS_BORDER  一定要有WS_BORDER否则没法双缓冲
Gui, +AlwaysOnTop -DPIScale +ToolWindow +HwndMyGuiHwnd  +E0x02000000 +E0x00080000 ;+E0x02000000 +E0x00080000 双缓冲


set_region:
WinGetPos, X, Y, W, H, ahk_id %MyGuiHwnd%
WinSet, Region, 1-1 W%W% H%H% R5-5, ahk_id %MyGuiHwnd%

DllCall("dwmapi\DwmSetWindowAttribute", "ptr", myguihwnd
  , "uint", DWMWA_NCRENDERING_POLICY := 2, "int*", DWMNCRP_DISABLED := 1, "uint", 4)
return</Item>
			<Item name="边框颜色" tv="10206816">#Persistent

SetTimer, DrawRect, 50
border_thickness = 5
border_color = FF0000

DrawRect:
WinGetPos, x, y, w, h, A
if (x="")
    return
Gui, +Lastfound +AlwaysOnTop +Toolwindow

borderType:="inside"                ; set to inside, outside, or both

if (borderType="outside") { 
    outerX:=0
    outerY:=0
    outerX2:=w+2*border_thickness
    outerY2:=h+2*border_thickness

    innerX:=border_thickness
    innerY:=border_thickness
    innerX2:=border_thickness+w
    innerY2:=border_thickness+h

    newX:=x-border_thickness
    newY:=y-border_thickness
    newW:=w+2*border_thickness
    newH:=h+2*border_thickness

} else if (borderType="inside") {   
    WinGet, myState, MinMax, A
    if (myState=1)
        offset:=8
    else 
        offset:=0

    outerX:=offset
    outerY:=offset
    outerX2:=w-offset
    outerY2:=h-offset

    innerX:=border_thickness+offset
    innerY:=border_thickness+offset
    innerX2:=w-border_thickness-offset
    innerY2:=h-border_thickness-offset

    newX:=x
    newY:=y
    newW:=w
    newH:=h



} else if (borderType="both") { 
    outerX:=0
    outerY:=0
    outerX2:=w+2*border_thickness
    outerY2:=h+2*border_thickness

    innerX:=border_thickness*2
    innerY:=border_thickness*2
    innerX2:=w
    innerY2:=h

    newX:=x-border_thickness
    newY:=y-border_thickness
    newW:=w+4*border_thickness
    newH:=h+4*border_thickness
}



Gui, Color, %border_color%
Gui, -Caption

;WinSet, Region, 0-0 %w%-0 %w%-%h% 0-%h% 0-0 %border_thickness%-%border_thickness% %iw%-%border_thickness% %iw%-%ih% %border_thickness%-%ih% %border_thickness%-%border_thickness%
 WinSet, Region, %outerX%-%outerY% %outerX2%-%outerY% %outerX2%-%outerY2% %outerX%-%outerY2% %outerX%-%outerY%    %innerX%-%innerY% %innerX2%-%innerY% %innerX2%-%innerY2% %innerX%-%innerY2% %innerX%-%innerY% 


;Gui, Show, w%w% h%h% x%x% y%y% NoActivate, Table awaiting Action
Gui, Show, w%newW% h%newH% x%newX% y%newY% NoActivate, Table awaiting Action
return</Item>
			<Item name="播放声音" tv="10205136">FileRead, memWav, *c C:\Windows\Media\Windows Ding.wav

DllCall("Winmm\PlaySound", "ptr", &amp;memWav, "ptr", 0, "uint", 4 | 1)
Sleep, 1500
DllCall("Winmm\PlaySound", "ptr", &amp;memWav, "ptr", 0, "uint", 4 | 1)
Sleep, 1500

https://docs.microsoft.com/zh-CN/previous-versions//dd743680(v=vs.85)#:~:text=fdwSound%0AFlags%20for%20playing%20the%20sound.%20The%20following%20values%20are%20defined.</Item>
			<Item name="透明边框" tv="10207488">b:=10   ; border in px . This is black border
t=false ; variables are set by default to false, this line not needed but added for clarity

;----------------
; This Initializes the window
;----------------

Gui,+Resize                 ; window resizable (drag)
Gui, Color, EEAA99          ; Initializes Color so not-everything transparent
Gui +LastFound              ; Makes GUI the same background color as your regular window GUI apps
WinSet, TransColor, EEAA99  ; Sets transparency
Gui,Show,w500 h500          ;  This sets width and height
return                      ; sends input

;------------
; Below is HotKey
;------------

F1::           

    t:=!t                                                           ; T is false default, changes to true upon first F1 push 
    if t {                                                          ; makes the "black border" unmovable window

        Gui, -Caption +ToolWindow +LastFound -Resize  +AlwaysOnTop   ; "ToolWindow: Provides a narrower title bar but the window will have no taskbar button" -Caption "removes border and title bar",       
        Gui, Color, Black                                           ; This sets color of border, causes temporary "black screen flash"
        WinGetPos,,,w,h
        q:=w-b, z:=h-b                                                                         ; precalculates border
        WinSet, Region, 0-0 %w%-0 %w%-%h% 0-%h% 0-0  %b%-%b% %q%-%b% %q%-%z% %b%-%z% %b%-%b%   ; Creates "black border"
    }
    else {                                                          ; This secion resets to default 

        Gui, +Caption -ToolWindow +LastFound +Resize -AlwaysOnTop              

        Gui, Color, EEAA99 ;               
        Gui +LastFound  ; Make the GUI window the last found window for use by the line below.
        WinSet, TransColor, EEAA99  ;

        WinSet,Region
    }
return</Item>
			<Item name="edit插入文本" tv="10205360">lineIndex := 2
insertText := "xxxxxxxx`n"

hwnd := ControlGetHwnd("edit1", "ahk_class Notepad")
charIndex := SendMessage(EM_LINEINDEX := 0x00BB, lineIndex, 0, hwnd)
SendMessage(EM_SETSEL := 0x00B1, charIndex, charIndex, hwnd)
EditPaste(insertText, hwnd)</Item>
			<Item name="16进制读写" tv="10205696">; https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinaryw
CryptStringToBinary(str, flag){
	DllCall("crypt32\CryptStringToBinaryW", "str", str, "uint", StrLen(str), "uint", flag, "ptr", 0, "uint*", &amp;bytes := 0, "ptr", 0, "ptr", 0)
	DllCall("crypt32\CryptStringToBinaryW", "str", str, "uint", StrLen(str), "uint", flag, "ptr", bin := Buffer(bytes), "uint*", bytes, "ptr", 0, "ptr", 0)
	return bin
}
; https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringw
CryptBinaryToString(bin, flag){
	DllCall("crypt32\CryptBinaryToStringW", "ptr", bin, "uint", bin.Size, "uint", flag, "ptr", 0, "uint*", &amp;cnt := 0)
	DllCall("crypt32\CryptBinaryToStringW", "ptr", bin, "uint", bin.Size, "uint", flag, "ptr", str := Buffer(cnt * 2), "uint*", cnt)
	return StrGet(str)
}

bin := FileRead(A_ScriptFullPath, "raw")
str := CryptBinaryToString(bin, 0x00000004 | 0x40000000)
MsgBox str
str := RegExReplace(str, "61 61 61 61 61", "62 62 62 62 62")
bin := CryptStringToBinary(str, 4)
FileAppend(bin, "out.ah2", "raw")
; aaaaa</Item>
			<Item name="v2base64" tv="10206256">; ===========================================================================================================================================================================
; StringToBase64
; Converts a readable string to a base64 string.
; MsgBox StringToBase64("The quick brown fox jumps over the lazy dog")    ; VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZwA=
; ===========================================================================================================================================================================

StringToBase64(String, Encoding := "UTF-8")
{
	static CRYPT_STRING_BASE64 := 0x00000001
	static CRYPT_STRING_NOCRLF := 0x40000000

	Binary := Buffer(StrPut(String, Encoding))
	StrPut(String, Binary, Encoding)
	if !(DllCall("crypt32\CryptBinaryToStringW", "Ptr", Binary, "UInt", Binary.Size, "UInt", (CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF), "Ptr", 0, "UInt*", &amp;Size := 0))
		throw Error("CryptBinaryToStringW failed", -1)

	Base64 := Buffer(Size &lt;&lt; 1, 0)
	if !(DllCall("crypt32\CryptBinaryToStringW", "Ptr", Binary, "UInt", Binary.Size, "UInt", (CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF), "Ptr", Base64, "UInt*", Size))
		throw Error("CryptBinaryToStringW failed", -1)

	return StrGet(Base64)
}

; ===========================================================================================================================================================================
; Base64ToString
; Converts a base64 string to a readable string.
; MsgBox Base64ToString("VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZwA=")    ; The quick brown fox jumps over the lazy dog
; ===========================================================================================================================================================================

Base64ToString(Base64)
{
	static CRYPT_STRING_BASE64 := 0x00000001

	if !(DllCall("crypt32\CryptStringToBinaryW", "Str", Base64, "UInt", 0, "UInt", CRYPT_STRING_BASE64, "Ptr", 0, "UInt*", &amp;Size := 0, "Ptr", 0, "Ptr", 0))
		throw Error("CryptBinaryToString failed", -1)

	String := Buffer(Size, 0)
	if !(DllCall("crypt32\CryptStringToBinaryW", "Str", Base64, "UInt", 0, "UInt", CRYPT_STRING_BASE64, "Ptr", String, "UInt*", Size, "Ptr", 0, "Ptr", 0))
		throw Error("CryptBinaryToString failed", -1)

	return StrGet(String, "UTF-8")
}

; ===========================================================================================================================================================================</Item>
			<Item name="v2冒泡排序" tv="10207600">rtn := bubble_sort(arr, 1, arr.Length, my_compare)
logger.info(rtn)

/*
 * 冒泡排序
 * @param arr [IN] 输入数组
 * @param l,h 排序[l-h]行
 * @param compare 自定义排序规则，默认降序，从大到小
 * @return arr 结果
 */
bubble_sort(arr, l, h, compare := unset)
{
    while(l &lt; h)
    {
        j := l
        while(j &lt; h)
        {
            if(IsSet(compare))
            {
                if(compare(arr[j], arr[j+1]))
                    tmp := arr[j+1] , arr[j+1] := arr[j] ,arr[j] := tmp
            }
            else
            {
                if(arr[j] &lt; arr[j+1])
                    tmp := arr[j+1] , arr[j+1] := arr[j] ,arr[j] := tmp
            }
            j++
        }
        h--
    }
    return arr
}

my_compare(a, b)
{
    return a &lt; b ? true : false
}</Item>
			<Item name="正则匹配知识点" tv="10206928">by feiyue
我发现ahk帮助文件中的正则表达式说明中漏了一条重要的知识点：
*模式匹配中的后引用
例如：
s:="abc123abc"
re:="(\D+).*?\1"
msgbox % s~=re</Item>
			<Item name="buffer 对象" tv="10206368">#include &lt;log&gt;

obj := vector2(1, 30)
logger.info(obj.x)
obj.x := 2
logger.info(obj.x)
logger.info(obj.ptr)
logger.info(obj.y)
class vector2 extends Buffer
{
    __New(x, y) 
    {
        super.__New(8, 0)
        NumPut("int", x, "int", y, this.Ptr)
    }
    __Get(Key, Params) 
    {
        if(key == 'x')
        {
            return NumGet(this.Ptr, 0, "int")
        }
        else if(key == 'y')
        {
            return NumGet(this.Ptr, 4, "int")
        }
    }
    __Set(Key, Params, Value) 
    {
        if(key == 'x')
        {
            NumPut("int", Value, this.Ptr)
        }
        else if(key == 'y')
        {
            NumPut("int", Value, this.Ptr, 4)
        }
    }
}



class Structure {
	Size := %this.__Class%.Size
	__New(ptr := unset) =&gt; this.Ptr := IsSet(ptr) ? ptr : (this.__Buf := Buffer(this.Size)).Ptr
}

class _POINT extends Structure {
	static Size := 8
	x{
		get =&gt; NumGet(this, "int")
		set =&gt; NumPut("int", Value, this)
	}
	y{
		get =&gt; NumGet(this, 4, "int")
		set =&gt; NumPut("int", Value, this, 4)
	}
}
class _POINT extends Buffer {
	__New() =&gt; super.__New(8)
	x{
		get =&gt; NumGet(this, "int")
		set =&gt; NumPut("int", Value, this)
	}
	y{
		get =&gt; NumGet(this, 4, "int")
		set =&gt; NumPut("int", Value, this, 4)
	}
}</Item>
			<Item name="hook闪烁消息" tv="10207040">Persistent
; 监控窗口闪烁
f1::DllCall("FlashWindow", "ptr", WinExist("A"), "int", true)
hook := ShellHook((wParam, lParam, *) =&gt; wParam == 32774 &amp;&amp; ToolTip(WinGetClass(lParam) " 闪烁了"))

class ShellHook {
	static Message := DllCall("RegisterWindowMessage", "str", "ShellHook")

	static RefCount := 0

    __New(function) {
        !ShellHook.RefCount++ ? DllCall("RegisterShellHookWindow", "ptr", A_ScriptHwnd) : ""
        OnMessage(ShellHook.Message, this.function := function)
    }

    __Delete() {
        !--ShellHook.RefCount ? DllCall("DeregisterShellHookWindow", "ptr", A_ScriptHwnd) : ""
        OnMessage(ShellHook.Message, this.function, 0)
    }
}</Item>
			<Item name="ptr*封装" tv="10206480">#DllLoad combase.dll
class HString {
	ptr := 0
	__New(str) =&gt; DllCall('combase\WindowsCreateString', 'wstr', str, 'uint', StrLen(str), 'ptr*', this)
	__Delete() =&gt; DllCall('combase\WindowsDeleteString', 'ptr', this)
}
;thqby


class HString
{
	static New(str) =&gt; (DllCall("Combase\WindowsCreateString", "wstr", str, "uint", StrLen(str), "ptr*", &amp;hstr := 0), HString(hstr))
	__New(ptr) =&gt; this.Ptr := ptr
	__Delete() =&gt; DllCall("Combase\WindowsDeleteString", "ptr", this)
	ToString() =&gt; StrGet(this.Ptr + 28)
}
;Tebayaki
</Item>
			<Item name="v2 socket" tv="10208688">#include &lt;Socket&gt;
DC_SERV := true
DC_CLI := false

server := Socket()
server.onAccept := OnAccept
server.Bind(["0.0.0.0", 8000])
server.Listen()

loop
{
    x := Socket()
    x.Connect(["127.0.0.1", 8000])
    x.SendText(A_Index)
    Sleep 500
    if(DC_CLI)
        x.Disconnect()
}

OnAccept(server)
{
    sock := server.Accept()
    ToolTip(sock.RecvText())
    if(DC_SERV)
        sock.Disconnect()
}</Item>
			<Item name="包装器" tv="10208576">#include &lt;log4ahk&gt;

__Call := MsgBox.Call.Bind(MsgBox)
MsgBox.DefineProp("Call", {call : (this, msg, *) =&gt; (log.info(msg), __Call(msg))})

MsgBox(123)

wrap(this, method, param*)
{
    ToolTip "wrap"
    method(this, param*)
}
class m
{
    static __New() 
    {
        t := this.hello
        this.DefineProp('hello', {call : (self ,n) =&gt; wrap(self, t, n)})
    }
    static hello(n)
    {
        MsgBox n
    }
}
m.hello('ahk')</Item>
			<Item name="customtooltip" tv="10208464">title := "Hello,"
text := "This is my custom ToolTip!`nIt will disappear in five seconds."

hToolTip := CustomToolTip(text,,, title, 1, true, 0xFFC141, 0x50669F, "Calibri", "s18", true, 5000)
                          
Timer := Func("UpdateText").Bind(hToolTip, [ StrReplace(text, "five seconds", "one second")
                                              , StrReplace(text, "five", "two")
                                              , StrReplace(text, "five", "three")
                                              , StrReplace(text, "five", "four") ])
SetTimer, % Timer, 1000
Return

CustomToolTip( text, x := "", y := "", title := ""
             , icon := 0  ; can be 1 — Info, 2 — Warning, 3 — Error, if greater than 3 — hIcon
             , closeButton := false, backColor := "", textColor := 0
             , fontName := "", fontOptions := ""  ; like in GUI
             , isBallon := false, timeout := "", maxWidth := 600 )
{
   static ttStyles := (TTS_NOPREFIX := 2) | (TTS_ALWAYSTIP := 1), TTS_BALLOON := 0x40, TTS_CLOSE := 0x80
        , TTF_TRACK := 0x20, TTF_ABSOLUTE := 0x80
        , TTM_SETMAXTIPWIDTH := 0x418, TTM_TRACKACTIVATE := 0x411, TTM_TRACKPOSITION := 0x412
        , TTM_SETTIPBKCOLOR := 0x413, TTM_SETTIPTEXTCOLOR := 0x414
        , TTM_ADDTOOL        := A_IsUnicode ? 0x432 : 0x404
        , TTM_SETTITLE       := A_IsUnicode ? 0x421 : 0x420
        , TTM_UPDATETIPTEXT  := A_IsUnicode ? 0x439 : 0x40C
        , exStyles := (WS_EX_TOPMOST := 0x00000008) | (WS_EX_COMPOSITED := 0x2000000) | (WS_EX_LAYERED := 0x80000)
        , WM_SETFONT := 0x30, WM_GETFONT := 0x31
   
   dhwPrev := A_DetectHiddenWindows, defGuiPrev := A_DefaultGui, lastFoundPrev := WinExist()
   DetectHiddenWindows, On
   hWnd := DllCall("CreateWindowEx", "UInt", exStyles, "Str", "tooltips_class32", "Str", ""
                                   , "UInt", ttStyles | TTS_CLOSE * !!CloseButton | TTS_BALLOON * !!isBallon
                                   , "Int", 0, "Int", 0, "Int", 0, "Int", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr", 0, "Ptr")
   WinExist("ahk_id" . hWnd)
   if (textColor != 0 || backColor != "") {
      DllCall("UxTheme\SetWindowTheme", "Ptr", hWnd, "Ptr", 0, "UShortP", empty := 0)
      ByteSwap := Func("DllCall").Bind("msvcr100\_byteswap_ulong", "UInt")
      SendMessage, TTM_SETTIPBKCOLOR  , ByteSwap.Call(backColor &lt;&lt; 8)
      SendMessage, TTM_SETTIPTEXTCOLOR, ByteSwap.Call(textColor &lt;&lt; 8)
   }
   if (fontName || fontOptions) {
      Gui, New
      Gui, Font, % fontOptions, % fontName
      Gui, Add, Text, hwndhText
      SendMessage, WM_GETFONT,,,, ahk_id %hText%
      SendMessage, WM_SETFONT, ErrorLevel
      Gui, Destroy
      Gui, %defGuiPrev%: Default
   }
   VarSetCapacity(TOOLINFO, sz := 24 + A_PtrSize*6, 0)
   NumPut(sz, TOOLINFO)
   NumPut(TTF_TRACK | TTF_ABSOLUTE * !isBallon, TOOLINFO, 4)
   NumPut(&amp;text, TOOLINFO, 24 + A_PtrSize*3)
   
   if (x = "" || y = "")
      DllCall("GetCursorPos", "Int64P", pt)
   (x = "" &amp;&amp; x := (pt &amp; 0xFFFFFFFF) + 15), (y = "" &amp;&amp; y := (pt &gt;&gt; 32) + 15)
   
   SendMessage, TTM_SETTITLE      , icon, &amp;title
   SendMessage, TTM_TRACKPOSITION ,     , x | (y &lt;&lt; 16)
   SendMessage, TTM_SETMAXTIPWIDTH,     , maxWidth
   SendMessage, TTM_ADDTOOL       ,     , &amp;TOOLINFO
   SendMessage, TTM_UPDATETIPTEXT ,     , &amp;TOOLINFO
   SendMessage, TTM_TRACKACTIVATE , true, &amp;TOOLINFO
   
   if timeout {
      Timer := Func("DllCall").Bind("DestroyWindow", "Ptr", hWnd)
      SetTimer, % Timer, % "-" . timeout
   }
   DetectHiddenWindows, % dhwPrev
   WinExist("ahk_id" . lastFoundPrev)
   Return hWnd
}

UpdateText(hTooltip, TextArray) {
   static TTM_UPDATETIPTEXT := A_IsUnicode ? 0x439 : 0x40C
   text := TextArray.Pop()
   VarSetCapacity(TOOLINFO, sz := 24 + A_PtrSize*6, 0)
   NumPut(sz, TOOLINFO)
   NumPut(&amp;text, TOOLINFO, 24 + A_PtrSize*3)
   SendMessage, TTM_UPDATETIPTEXT,, &amp;TOOLINFO,, ahk_id %hTooltip%
   if (TextArray[1] = "")
      SetTimer,, Delete
}</Item>
			<Item name="v2事件event类" tv="10210144">Persistent
;; 创建事件
evt := Event("MyEvent")
;; 通知
f1::evt.Set()

class Event {
	static Open(name, dwDesiredAccess := 0x1f0003, bInheritHandle := false){
		if !hEvt := DllCall("OpenEventW", "uint", dwDesiredAccess, "int", bInheritHandle, "str", name, "ptr")
			throw OSError()
		return (ins := {Base: this.Prototype, Ptr: hEvt}, ins.__Init(), ins)
	}

	__New(name := unset, dwFlags := 1, dwDesiredAccess := 0x1f0003, lpSemaphoreAttributes := 0) {
		if !this.Ptr := DllCall("CreateEventExW", "ptr", 0, "ptr", IsSet(name) ? StrPtr(name) : 0, "uint", dwFlags, "uint", dwDesiredAccess, "ptr")
			throw OSError()
	}

	__Delete() =&gt; this.Ptr &amp;&amp; DllCall("CloseHandle", "ptr", this)

	Set() =&gt; DllCall("SetEvent", "ptr", this)

	Reset() =&gt; DllCall("ResetEvent", "ptr", this)
}

WaitForSingleObject(handle, timeout := -1) =&gt; DllCall("WaitForSingleObject", "ptr", handle, "uint", timeout, "uint")</Item>
			<Item name="tooltip编辑框edit" tv="10209584">TipGuiEscape:
Gui, Tip:Destroy
Return

tip(ttext := "", x := 0, y := 0) {
 If (ttext &gt; "") {
  Gui, Tip:New, +ToolWindow -Caption +AlwaysOnTop
  Gui, Margin, 1, 1
  Gui, Add, Edit, r30  ReadOnly Multi, %ttext%
  Gui, Show, X%x% Y%y% NoActivate  AutoSize
 } Else Gui, Tip:Destroy
}</Item>
			<Item name="提示框tooltip" tv="10208016">PleasantNotify("PleasantNotify", "position t hc" , 600, 210, "t hc", "3")
Sleep, 3000
PleasantNotify("PleasantNotify", "position b hc" , 600, 210, "b hc", "3")
Sleep, 3000
PleasantNotify("PleasantNotify", "position default, b r" , 600, 210, "b r", "3")
Sleep, 3000
PleasantNotify("PleasantNotify", "position b l" , 600, 210, "b l", "3")
Sleep, 3000
PleasantNotify("PleasantNotify", "position t l" , 600, 210, "t l", "3")
Sleep, 3000
PleasantNotify("PleasantNotify", "position t r" , 600, 210, "t r", "3")
return

PleasantNotify(title, message, pnW=700, pnH=300, position="b r", time=10) {
    global pn_title, pn_msg, PN_hwnd, w, h
	Notify_Destroy()
	Gui, Notify: +AlwaysOnTop +ToolWindow -SysMenu -Caption +LastFound
	PN_hwnd := WinExist()
	WinSet, ExStyle, +0x20
	WinSet, Transparent, 0
	Gui, Notify: Color, 0xF2F2F0
	Gui, Notify: Font, c0x07D82F s18 wBold, Segoe UI
	Gui, Notify: Add, Text, % " x" 20 " y" 12 " w" pnW-20 " vpn_title", % title
	Gui, Notify: Font, cBlack s15 wRegular
	Gui, Notify: Add, Text, % " x" 20 " y" 56 " w" pnW-20 " h" pnH-56 " vpn_msg", % message
	RealW := pnW + 50
	RealH := pnH + 20
	Gui, Notify: Show, W%RealW% H%RealH% NoActivate
	WinMove(PN_hwnd, position)
	if A_ScreenDPI = 96
		WinSet, Region,0-0 w%pnW% h%pnH% R40-40,%A_ScriptName%
	/* For Screen text size 125%
	if A_ScreenDPI = 120
		WinSet, Region, 0-0 w800 h230 R40-40, %A_ScriptName%
	*/
	winfade("ahk_id " PN_hwnd,210,5)
	if (time &lt;&gt; "P")
	{
		Closetick := time*1000
		SetTimer, ByeNotify, % Closetick
	}
}

Notify_Destroy() {
	global PN_hwnd
	ByeNotify:
	SetTimer, ByeNotify, Off
    winfade("ahk_id " PN_hwnd,0,5)
    Gui, Notify: Destroy
	return
}

pn_mod_title(title) {
	global pn_title
	GuiControl, Notify: Text,pn_title, % title
}

pn_mod_msg(message) {
	global pn_msg
	GuiControl, Notify: Text,pn_msg, % message
}

WinMove(hwnd,position) {
   SysGet, Mon, MonitorWorkArea
   WinGetPos,ix,iy,w,h, ahk_id %hwnd%
   x := InStr(position,"l") ? MonLeft : InStr(position,"hc") ?  (MonRight-w)/2 : InStr(position,"r") ? MonRight - w : ix
   y := InStr(position,"t") ? MonTop : InStr(position,"vc") ?  (MonBottom-h)/2 : InStr(position,"b") ? MonBottom - h : iy
   WinMove, ahk_id %hwnd%,,x,y
}

winfade(w:="",t:=128,i:=1,d:=10) {
    w:=(w="")?("ahk_id " WinActive("A")):w
    t:=(t&gt;255)?255:(t&lt;0)?0:t
    WinGet,s,Transparent,%w%
    s:=(s="")?255:s ;prevent trans unset bug
    WinSet,Transparent,%s%,%w%
    i:=(s&lt;t)?abs(i):-1*abs(i)
    while(k:=(i&lt;0)?(s&gt;t):(s&lt;t)&amp;&amp;WinExist(w)) {
        WinGet,s,Transparent,%w%
        s+=i
        WinSet,Transparent,%s%,%w%
        sleep %d%
    }
}</Item>
			<Item name="可移动movetooltip" tv="10209024">text = 
(%
UpdateText(hTooltip, TextArray) {
   static TTM_UPDATETIPTEXT := A_IsUnicode ? 0x439 : 0x40C
   text := TextArray.Pop()
   VarSetCapacity(TOOLINFO, sz := 24 + A_PtrSize*6, 0)
   NumPut(sz, TOOLINFO)
   NumPut(&amp;text, TOOLINFO, 24 + A_PtrSize*3)
   SendMessage, TTM_UPDATETIPTEXT,, &amp;TOOLINFO,, ahk_id %hTooltip%
   if (TextArray[1] = "")
      SetTimer,, Delete
)
#NoEnv
OnMessage(0x201, "WM_LBUTTONDOWN")

Global tClass:="SysShadow,Alternate Owner,tooltips_class32,DummyDWMListenerWindow,EdgeUiInputTopWndClass,ApplicationFrameWindow,TaskManagerWindow,Qt5QWindowIcon,Windows.UI.Core.CoreWindow,WorkerW,Progman,Internet Explorer_Hidden,Shell_TrayWnd" ; HH Parent

WinGetActiveTitle, aWin
ToolTip,% text, 0, 0
return

WM_LBUTTONDOWN(wParam, lParam, msg, hwnd) {
	PostMessage, 0xA1, 2 ; WM_NCLBUTTONDOWN
	KeyWait, LButton, U
	Loop { ; adapted from https://autohotkey.com/board/topic/32171-how-to-get-the-id-of-the-next-or-previous-window-in-z-order/
        ; GetWindow() returns a decimal value, so we have to convert it to hex
        ; GetWindow() processes even hidden windows, so we move down the z oder until the next visible window is found
        hwnd := Format("0x{:x}", DllCall("GetWindow", UPtr,hwnd, UInt,2) ) ; 2 = GW_HWNDNEXT
        if DllCall("IsWindowVisible", UPtr,hwnd) {
            WinGet, Ex, ExStyle, ahk_id %hwnd%
            ;if ( IsWindowCloaked(hwnd) || Ex &amp; (0x8 | 0x80 | 0x8000000) ) ;WS_EX_TOPMOST, WS_EX_TOOLWINDOW, WS_EX_NOACTIVATE
            if (IsWindowCloaked(hwnd) || Ex &amp; 0x8000088) ;WS_EX_TOPMOST, WS_EX_TOOLWINDOW, WS_EX_NOACTIVATE
		Continue
            WinGetClass, cClass, ahk_id %hwnd%
            if InStr(tClass, cClass, 1) ; if cClass in %tClass%
                Continue
            else break
        }
    }   WinActivate, ahk_id %hwnd%
}

IsWindowCloaked(hwnd) {
    return DllCall("dwmapi\DwmGetWindowAttribute", "ptr",hwnd, "int",14, "int*",cloaked, "int",4) &gt;= 0
        &amp;&amp; cloaked
}

Esc::exitapp</Item>
			<Item name="移动gui" tv="10208800">#NoEnv
Gui, +AlwaysOnTop +Border -Caption +HwndhGui +ToolWindow +E0x08000000
Gui, Margin, 20, 20
Gui, Add, Button,          w150 gSendChr, a
Gui, Add, Button,       ym wp   gSendChr, h
Gui, Add, Button,       ym wp   gSendChr, k
Gui, Add, Button, xm       wp   vMove, Move
Gui, Add, Button, x+190 yp wp   gGuiClose, Exit
Gui, Show, NA, On Screen Keyboard Demo
OnMessage(0x0201, "WM_LBUTTONDOWN")
Return

GuiClose:
ExitApp

SendChr:
	k := GetKeyState("CapsLock", "T") ? Format("{:U}", A_GuiControl) : A_GuiControl
	SendInput, % "{" k "}"
Return

WM_LBUTTONDOWN() {
   If (A_GuiControl = "Move") {
      PostMessage, 0xA1, 2
      Return 0
   }
}
;https://www.autohotkey.com/boards/viewtopic.php?t=74190</Item>
			<Item name="控件颜色修改" tv="10210592">;https://www.autohotkey.com/boards/viewtopic.php?f=6&amp;t=2197&amp;hilit=CtlColor_Edit
#NoEnv
OnExit, GuiClose
; ----------------------------------------------------------------------------------------------------------------------
SysGet, SGW, 71 ; SM_CXMENUCHECK
LB_SETCURSEL := 0x186
CB_SETCURSEL := 0x14E
Red   := "FF0000"
Green := "00C000"
Blue  := "0000FF"
Pink  := "FF20FF"
; ----------------------------------------------------------------------------------------------------------------------
Gui, Margin, 10, 10
Gui, Add, Radio, vSTDRB1 gSTDRBG hwndRBID1 Checked, Standard Radio 1
CtlColors.Attach(RBID1, "Lime", "")
Gui, Add, Radio, x+55 ym vSTDRB2 gSTDRBG hwndRBID2, Standard Radio 2
Gui, Add, CheckBox, xm vSTDCB1 gSTDCB1 hwndCBID1, Standard CheckBox
CtlColors.Attach(CBID1, "C0C0C0", "Red")
; ----------------------------------------------------------------------------------------------------------------------
Gui, Add, Text, xm w292 h2 +0x1000
; "Faked" RadioButtons -------------------------------------------------------------------------------------------------
; Note: Minimum width and height are font, font size and OS dependend, if you get below the limit, nothing is shown!!!
Gui, Add, Radio, xm w%SGW% h20 gRBG vRB1 Section Group Checked
Gui, Add, Radio, xm wp hp gRBG vRB2
Gui, Add, Radio, xm wp hp gRBG vRB3
Gui, Add, Text, ys x+5 w50 hp 0x200 cBlue gRBG vRT1 hwndRTID1, % "Radio 1"
Gui, Add, Text, xp y+10 wp hp 0x200 cBlue gRBG vRT2 hwndRTID2, % "Radio 2"
Gui, Add, Text, xp y+10 wp hp 0x200 cBlue gRBG vRT3 hwndRTID3, % "Radio 3"
RBGA := 1
CtlColors.Attach(RTID%RBGA%, "Yellow", "Blue")
; "Faked" CheckBox -----------------------------------------------------------------------------------------------------
; Note: for minimum width see "Faked" RadioButtons
Gui, Add, CheckBox, ys x+80 w%SGW% h20 gCB1 vCB1 Section
Gui, Add, Text, x+5 yp hp 0x200 gCB1 vCT1 hwndCTID1, % " Check me! "
CtlColors.Attach(CTID1, "", "Green")
; ComboBox -------------------------------------------------------------------------------------------------------------
Gui, Add, Combobox, xs y+40 w141 gCBB1 vCBB1 hwndCBBID1
   , ComboBox 1||ComboBox 2|ComboBox 3
CtlColors.Attach(CBBID1, "Aqua", "Red")
; ----------------------------------------------------------------------------------------------------------------------
Gui, Add, Text, xm w292 h2 +0x1000
; ListBox --------------------------------------------------------------------------------------------------------------
Gui, Add, ListBox, xm w292 r4 gLB1 vLB1 hwndLBID1
   , ListBox Red|ListBox Green|ListBox Blue|ListBox Pink
CtlColors.Attach(LBID1, Red, "White")
GuiControl, Choose, LB1, |1
; ----------------------------------------------------------------------------------------------------------------------
Gui, Add, Text, xm w292 h2 +0x1000
; Edit -----------------------------------------------------------------------------------------------------------------
Gui, Font, s10
Gui, Add, Edit, xm w292 r10 vED1 hwndEDID1, I'm an Edit, edit me!
CtlColors.Attach(EDID1, "606060", "Aqua")
Gui, Add, Edit, xm w292 vED2 hwndEDID2 +Disabled, % " I'm disabled!"
CtlColors.Attach(EDID2, "Gray", "Lime")
; ----------------------------------------------------------------------------------------------------------------------
Gui, Show, , Colored Controls
Return
; ----------------------------------------------------------------------------------------------------------------------
GuiClose:
GuiEscape:
   Gui, Destroy
   CtlColors.Free()
ExitApp
; ----------------------------------------------------------------------------------------------------------------------
GuiSize:
   If (A_EventInfo != 1) {
      Gui, %A_Gui%:+LastFound
      WinSet, ReDraw
   }
Return
; ----------------------------------------------------------------------------------------------------------------------
STDRBG:
   GuiControlGet, STDRB1
   CtlColors.Change(RBID1, (STDRB1 ? "Lime" : ""), "006000")
   CtlColors.Change(RBID2, (STDRB1 ? "" : "Lime"), "006000")
Return
; ----------------------------------------------------------------------------------------------------------------------
STDCB1:
   GuiControlGet, STDCB1
   CtlColors.Change(CBID1, (STDCB1 ? "Lime" : "C0C0C0"), "Red")
   Return
; ----------------------------------------------------------------------------------------------------------------------
RBG:
   RBG := SubStr(A_GuiControl, 3)
   If (RBG != RBGA) {
      CtlColors.Detach(RTID%RBGA%)
      CtlColors.Attach(RTID%RBG%, "Yellow", "Blue")
      GuiControl, , RB%RBG%, 1
      RBGA := RBG
   }
Return
; ----------------------------------------------------------------------------------------------------------------------
LB1:
   GuiControlGet, LB1
   StringSplit, LC, LB1, %A_Space%
   If (%LC2%) {
      BG := %LC2%, TX := "White"
      CtlColors.Change(LBID1, BG, TX)
      SendMessage, LB_SETCURSEL, -1, 0, , ahk_id %LBID1%
   }
Return
; ----------------------------------------------------------------------------------------------------------------------
CB1:
   GuiControlGet, CB1
   If (A_GuiControl = "CT1")
      CB1 ^= True
   If (CB1)
      CtlColors.Change(CTID1, "Lime", "406060")
   Else
      CtlColors.Change(CTID1, "", "Green")
   GuiControl, , CB1, %CB1%
Return
; ----------------------------------------------------------------------------------------------------------------------
CBB1:
Return
; AHK 1.1+
; ======================================================================================================================
; Function:          Auxiliary object to color controls on WM_CTLCOLOR... notifications.
;                    Supported controls are: Checkbox, ComboBox, DropDownList, Edit, ListBox, Radio, Text.
;                    Checkboxes and Radios accept only background colors due to design.
; Namespace:         CtlColors
; Tested with:       1.1.25.02
; Tested on:         Win 10 (x64)
; Change log:        1.0.04.00/2017-10-30/just me  -  added transparent background (BkColor = "Trans").
;                    1.0.03.00/2015-07-06/just me  -  fixed Change() to run properly for ComboBoxes.
;                    1.0.02.00/2014-06-07/just me  -  fixed __New() to run properly with compiled scripts.
;                    1.0.01.00/2014-02-15/just me  -  changed class initialization.
;                    1.0.00.00/2014-02-14/just me  -  initial release.
; ======================================================================================================================
; This software is provided 'as-is', without any express or implied warranty.
; In no event will the authors be held liable for any damages arising from the use of this software.
; ======================================================================================================================
Class CtlColors {
   ; ===================================================================================================================
   ; Class variables
   ; ===================================================================================================================
   ; Registered Controls
   Static Attached := {}
   ; OnMessage Handlers
   Static HandledMessages := {Edit: 0, ListBox: 0, Static: 0}
   ; Message Handler Function
   Static MessageHandler := "CtlColors_OnMessage"
   ; Windows Messages
   Static WM_CTLCOLOR := {Edit: 0x0133, ListBox: 0x134, Static: 0x0138}
   ; HTML Colors (BGR)
   Static HTML := {AQUA: 0xFFFF00, BLACK: 0x000000, BLUE: 0xFF0000, FUCHSIA: 0xFF00FF, GRAY: 0x808080, GREEN: 0x008000
                 , LIME: 0x00FF00, MAROON: 0x000080, NAVY: 0x800000, OLIVE: 0x008080, PURPLE: 0x800080, RED: 0x0000FF
                 , SILVER: 0xC0C0C0, TEAL: 0x808000, WHITE: 0xFFFFFF, YELLOW: 0x00FFFF}
   ; Transparent Brush
   Static NullBrush := DllCall("GetStockObject", "Int", 5, "UPtr")
   ; System Colors
   Static SYSCOLORS := {Edit: "", ListBox: "", Static: ""}
   ; Error message in case of errors
   Static ErrorMsg := ""
   ; Class initialization
   Static InitClass := CtlColors.ClassInit()
   ; ===================================================================================================================
   ; Constructor / Destructor
   ; ===================================================================================================================
   __New() { ; You must not instantiate this class!
      If (This.InitClass == "!DONE!") { ; external call after class initialization
         This["!Access_Denied!"] := True
         Return False
      }
   }
   ; ----------------------------------------------------------------------------------------------------------------
   __Delete() {
      If This["!Access_Denied!"]
         Return
      This.Free() ; free GDI resources
   }
   ; ===================================================================================================================
   ; ClassInit       Internal creation of a new instance to ensure that __Delete() will be called.
   ; ===================================================================================================================
   ClassInit() {
      CtlColors := New CtlColors
      Return "!DONE!"
   }
   ; ===================================================================================================================
   ; CheckBkColor    Internal check for parameter BkColor.
   ; ===================================================================================================================
   CheckBkColor(ByRef BkColor, Class) {
      This.ErrorMsg := ""
      If (BkColor != "") &amp;&amp; !This.HTML.HasKey(BkColor) &amp;&amp; !RegExMatch(BkColor, "^[[:xdigit:]]{6}$") {
         This.ErrorMsg := "Invalid parameter BkColor: " . BkColor
         Return False
      }
      BkColor := BkColor = "" ? This.SYSCOLORS[Class]
              :  This.HTML.HasKey(BkColor) ? This.HTML[BkColor]
              :  "0x" . SubStr(BkColor, 5, 2) . SubStr(BkColor, 3, 2) . SubStr(BkColor, 1, 2)
      Return True
   }
   ; ===================================================================================================================
   ; CheckTxColor    Internal check for parameter TxColor.
   ; ===================================================================================================================
   CheckTxColor(ByRef TxColor) {
      This.ErrorMsg := ""
      If (TxColor != "") &amp;&amp; !This.HTML.HasKey(TxColor) &amp;&amp; !RegExMatch(TxColor, "i)^[[:xdigit:]]{6}$") {
         This.ErrorMsg := "Invalid parameter TextColor: " . TxColor
         Return False
      }
      TxColor := TxColor = "" ? ""
              :  This.HTML.HasKey(TxColor) ? This.HTML[TxColor]
              :  "0x" . SubStr(TxColor, 5, 2) . SubStr(TxColor, 3, 2) . SubStr(TxColor, 1, 2)
      Return True
   }
   ; ===================================================================================================================
   ; Attach          Registers a control for coloring.
   ; Parameters:     HWND        - HWND of the GUI control                                   
   ;                 BkColor     - HTML color name, 6-digit hexadecimal RGB value, or "" for default color
   ;                 ----------- Optional 
   ;                 TxColor     - HTML color name, 6-digit hexadecimal RGB value, or "" for default color
   ; Return values:  On success  - True
   ;                 On failure  - False, CtlColors.ErrorMsg contains additional informations
   ; ===================================================================================================================
   Attach(HWND, BkColor, TxColor := "") {
      ; Names of supported classes
      Static ClassNames := {Button: "", ComboBox: "", Edit: "", ListBox: "", Static: ""}
      ; Button styles
      Static BS_CHECKBOX := 0x2, BS_RADIOBUTTON := 0x8
      ; Editstyles
      Static ES_READONLY := 0x800
      ; Default class background colors
      Static COLOR_3DFACE := 15, COLOR_WINDOW := 5
      ; Initialize default background colors on first call -------------------------------------------------------------
      If (This.SYSCOLORS.Edit = "") {
         This.SYSCOLORS.Static := DllCall("User32.dll\GetSysColor", "Int", COLOR_3DFACE, "UInt")
         This.SYSCOLORS.Edit := DllCall("User32.dll\GetSysColor", "Int", COLOR_WINDOW, "UInt")
         This.SYSCOLORS.ListBox := This.SYSCOLORS.Edit
      }
      This.ErrorMsg := ""
      ; Check colors ---------------------------------------------------------------------------------------------------
      If (BkColor = "") &amp;&amp; (TxColor = "") {
         This.ErrorMsg := "Both parameters BkColor and TxColor are empty!"
         Return False
      }
      ; Check HWND -----------------------------------------------------------------------------------------------------
      If !(CtrlHwnd := HWND + 0) || !DllCall("User32.dll\IsWindow", "UPtr", HWND, "UInt") {
         This.ErrorMsg := "Invalid parameter HWND: " . HWND
         Return False
      }
      If This.Attached.HasKey(HWND) {
         This.ErrorMsg := "Control " . HWND . " is already registered!"
         Return False
      }
      Hwnds := [CtrlHwnd]
      ; Check control's class ------------------------------------------------------------------------------------------
      Classes := ""
      WinGetClass, CtrlClass, ahk_id %CtrlHwnd%
      This.ErrorMsg := "Unsupported control class: " . CtrlClass
      If !ClassNames.HasKey(CtrlClass)
         Return False
      ControlGet, CtrlStyle, Style, , , ahk_id %CtrlHwnd%
      If (CtrlClass = "Edit")
         Classes := ["Edit", "Static"]
      Else If (CtrlClass = "Button") {
         IF (CtrlStyle &amp; BS_RADIOBUTTON) || (CtrlStyle &amp; BS_CHECKBOX)
            Classes := ["Static"]
         Else
            Return False
      }
      Else If (CtrlClass = "ComboBox") {
         VarSetCapacity(CBBI, 40 + (A_PtrSize * 3), 0)
         NumPut(40 + (A_PtrSize * 3), CBBI, 0, "UInt")
         DllCall("User32.dll\GetComboBoxInfo", "Ptr", CtrlHwnd, "Ptr", &amp;CBBI)
         Hwnds.Insert(NumGet(CBBI, 40 + (A_PtrSize * 2, "UPtr")) + 0)
         Hwnds.Insert(Numget(CBBI, 40 + A_PtrSize, "UPtr") + 0)
         Classes := ["Edit", "Static", "ListBox"]
      }
      If !IsObject(Classes)
         Classes := [CtrlClass]
      ; Check background color -----------------------------------------------------------------------------------------
      If (BkColor &lt;&gt; "Trans")
         If !This.CheckBkColor(BkColor, Classes[1])
            Return False
      ; Check text color -----------------------------------------------------------------------------------------------
      If !This.CheckTxColor(TxColor)
         Return False
      ; Activate message handling on the first call for a class --------------------------------------------------------
      For I, V In Classes {
         If (This.HandledMessages[V] = 0)
            OnMessage(This.WM_CTLCOLOR[V], This.MessageHandler)
         This.HandledMessages[V] += 1
      }
      ; Store values for HWND ------------------------------------------------------------------------------------------
      If (BkColor = "Trans")
         Brush := This.NullBrush
      Else
         Brush := DllCall("Gdi32.dll\CreateSolidBrush", "UInt", BkColor, "UPtr")
      For I, V In Hwnds
         This.Attached[V] := {Brush: Brush, TxColor: TxColor, BkColor: BkColor, Classes: Classes, Hwnds: Hwnds}
      ; Redraw control -------------------------------------------------------------------------------------------------
      DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
      This.ErrorMsg := ""
      Return True
   }
   ; ===================================================================================================================
   ; Change          Change control colors.
   ; Parameters:     HWND        - HWND of the GUI control
   ;                 BkColor     - HTML color name, 6-digit hexadecimal RGB value, or "" for default color
   ;                 ----------- Optional 
   ;                 TxColor     - HTML color name, 6-digit hexadecimal RGB value, or "" for default color
   ; Return values:  On success  - True
   ;                 On failure  - False, CtlColors.ErrorMsg contains additional informations
   ; Remarks:        If the control isn't registered yet, Add() is called instead internally.
   ; ===================================================================================================================
   Change(HWND, BkColor, TxColor := "") {
      ; Check HWND -----------------------------------------------------------------------------------------------------
      This.ErrorMsg := ""
      HWND += 0
      If !This.Attached.HasKey(HWND)
         Return This.Attach(HWND, BkColor, TxColor)
      CTL := This.Attached[HWND]
      ; Check BkColor --------------------------------------------------------------------------------------------------
      If (BkColor &lt;&gt; "Trans")
         If !This.CheckBkColor(BkColor, CTL.Classes[1])
            Return False
      ; Check TxColor ------------------------------------------------------------------------------------------------
      If !This.CheckTxColor(TxColor)
         Return False
      ; Store Colors ---------------------------------------------------------------------------------------------------
      If (BkColor &lt;&gt; CTL.BkColor) {
         If (CTL.Brush) {
            If (Ctl.Brush &lt;&gt; This.NullBrush)
               DllCall("Gdi32.dll\DeleteObject", "Prt", CTL.Brush)
            This.Attached[HWND].Brush := 0
         }
         If (BkColor = "Trans")
            Brush := This.NullBrush
         Else
            Brush := DllCall("Gdi32.dll\CreateSolidBrush", "UInt", BkColor, "UPtr")
         For I, V In CTL.Hwnds {
            This.Attached[V].Brush := Brush
            This.Attached[V].BkColor := BkColor
         }
      }
      For I, V In Ctl.Hwnds
         This.Attached[V].TxColor := TxColor
      This.ErrorMsg := ""
      DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
      Return True
   }
   ; ===================================================================================================================
   ; Detach          Stop control coloring.
   ; Parameters:     HWND        - HWND of the GUI control
   ; Return values:  On success  - True
   ;                 On failure  - False, CtlColors.ErrorMsg contains additional informations
   ; ===================================================================================================================
   Detach(HWND) {
      This.ErrorMsg := ""
      HWND += 0
      If This.Attached.HasKey(HWND) {
         CTL := This.Attached[HWND].Clone()
         If (CTL.Brush) &amp;&amp; (CTL.Brush &lt;&gt; This.NullBrush)
            DllCall("Gdi32.dll\DeleteObject", "Prt", CTL.Brush)
         For I, V In CTL.Classes {
            If This.HandledMessages[V] &gt; 0 {
               This.HandledMessages[V] -= 1
               If This.HandledMessages[V] = 0
                  OnMessage(This.WM_CTLCOLOR[V], "")
         }  }
         For I, V In CTL.Hwnds
            This.Attached.Remove(V, "")
         DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
         CTL := ""
         Return True
      }
      This.ErrorMsg := "Control " . HWND . " is not registered!"
      Return False
   }
   ; ===================================================================================================================
   ; Free            Stop coloring for all controls and free resources.
   ; Return values:  Always True.
   ; ===================================================================================================================
   Free() {
      For K, V In This.Attached
         If (V.Brush) &amp;&amp; (V.Brush &lt;&gt; This.NullBrush)
            DllCall("Gdi32.dll\DeleteObject", "Ptr", V.Brush)
      For K, V In This.HandledMessages
         If (V &gt; 0) {
            OnMessage(This.WM_CTLCOLOR[K], "")
            This.HandledMessages[K] := 0
         }
      This.Attached := {}
      Return True
   }
   ; ===================================================================================================================
   ; IsAttached      Check if the control is registered for coloring.
   ; Parameters:     HWND        - HWND of the GUI control
   ; Return values:  On success  - True
   ;                 On failure  - False
   ; ===================================================================================================================
   IsAttached(HWND) {
      Return This.Attached.HasKey(HWND)
   }
}
; ======================================================================================================================
; CtlColors_OnMessage
; This function handles CTLCOLOR messages. There's no reason to call it manually!
; ======================================================================================================================
CtlColors_OnMessage(HDC, HWND) {
   Critical
   If CtlColors.IsAttached(HWND) {
      CTL := CtlColors.Attached[HWND]
      If (CTL.TxColor != "")
         DllCall("Gdi32.dll\SetTextColor", "Ptr", HDC, "UInt", CTL.TxColor)
      If (CTL.BkColor = "Trans")
         DllCall("Gdi32.dll\SetBkMode", "Ptr", HDC, "UInt", 1) ; TRANSPARENT = 1
      Else
         DllCall("Gdi32.dll\SetBkColor", "Ptr", HDC, "UInt", CTL.BkColor)
      Return CTL.Brush
   }
}</Item>
			<Item name="json作为配置文件" tv="10211264" last="1">#include C:\Users\ahker\Desktop\我的AHK程序\库\v1\json.ahk

json_path := A_ScriptDir . "/json.json"
config := {}
loadconfig(config, json_path)
config.parameter1 := "ahk2"
saveconfig(config, json_path)
loadconfig(ByRef config, json_path)
{
    FileRead, OutputVar,% json_path
    config := json_toobj(outputvar)
}

saveconfig(config, json_path)
{
    str := json_fromobj(config)
    FileDelete, % json_path
    FileAppend,% str,% json_path
}</Item>
			<Item name="增加一个" tv="10210256">jj</Item></Item>
		<Item name="代码美化pretty" tv="10210704">run,http://sl5.it/SL5_preg_contentFinder/examples/AutoHotKey/converts_your_autohotkey_code_into_pretty_indented_source_code.php</Item></Item>
	<Item name="@cpp" tv="10208128">
		<Item name="帮助书册" tv="10209248"></Item>
		<Item name="在线编译" tv="10211600">run,https://godbolt.org/</Item>
		<Item name="cpp调用python" tv="10209696">run,https://blog.csdn.net/sxj731533730/article/details/117585607</Item>
		<Item name="代码段" tv="10208912">
			<Item name="字符串转换" tv="10209472">#include &lt;codecvt&gt;
//取消sd检查
std::string wstr_utf8(const std::wstring&amp; str)
{
    std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
    return myconv.to_bytes(str);
}
std::wstring utf8_wstr(const std::string&amp; str)
{
    std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
    return myconv.from_bytes(str);
}</Item>
			<Item name="文件注释" tv="10209920">/**************************************************************************

Copyright:HX

Author: tong.he

Date:2022-07-09

Description:模板练习

History:
    2022-07-09:update
        1)
        2)
        3)
    2022-07-10: 增加练习        
**************************************************************************/
</Item>
			<Item name="函数注释" tv="10209136">/** @brief swap two value

@param [IN, OUT] value1
@param [IN, OUT] value2

return void
*/
</Item>
			<Item name="计算耗时" tv="10211824">#include &lt;chrono&gt;   //计算时间
using namespace std::chrono;

auto starttime = system_clock::now();
...
duration&lt;double&gt; diff = system_clock::now()- starttime;
cout &lt;&lt; "所耗时间为：" &lt;&lt; diff.count() &lt;&lt; "s" &lt;&lt; endl;


#include "stdafx.h"
#include &lt;Windows.h&gt;
 
int main()
{
    long lBeginTime = MyGetTickCount();
    //------------------------
    //-------your code--------
    //------------------------
    long lTime = GetTickCountDIFF(lBeginTime); //计算your code耗时，lTime为最终耗时，单位为毫秒
        
    return 0;
}
long GetTickCountDIFF(long lBegin,long lNow = 0)
{
    if(0 == lBegin)
        return 0;
    if(0 == lNow)
        lNow = MyGetTickCount();
    long lDiff = lNow - lBegin;
    if(lDiff &lt; 0)
        lDiff = 0xFFFFFFFF - lBegin + lNow + 1;
    return lDiff;
}

long MyGetTickCount()
{
    static BOOL init = FALSE;
    static BOOL hires = FALSE;
    static _int64 freq = 1;
    if(!init)
    {
        hires = QueryPerformanceFrequency((LARGE_INTEGER*)&amp;freq);
        if(!hires)
            freq = 1000;
        init = TRUE;
    }
    _int64 now;
    if(hires)
        QueryPerformanceCounter((LARGE_INTEGER*)&amp;now);
    else
        now = GetTickCount();
    return (long)(1000.0f * (double)now/(double)freq);
}</Item>
			<Item name="窗口置顶" tv="10210816">windows置顶窗体终极方案
LRESULT OnForceShow(HWND hWnd)
{
	HWND hForeWnd = NULL; 
	DWORD dwForeID = 0; 
	DWORD dwCurID = 0; 
 
	hForeWnd =  ::GetForegroundWindow(); 
	dwCurID = :: GetCurrentThreadId(); 
	dwForeID =  ::GetWindowThreadProcessId( hForeWnd, NULL ); 
	::AttachThreadInput( dwCurID, dwForeID, TRUE); 
	::ShowWindow( hWnd, SW_SHOWNORMAL ); 
	::SetWindowPos( hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOSIZE|SWP_NOMOVE ); 
	::SetWindowPos( hWnd, HWND_NOTOPMOST, 0,0,0,0, SWP_NOSIZE|SWP_NOMOVE ); 
	::SetForegroundWindow( hWnd ); 
	::AttachThreadInput( dwCurID, dwForeID, FALSE);
 
	return S_OK;
}</Item>
			<Item name="读取字符串到string" tv="10208240">fstream myFile;
myFile.open("kzf.txt");
istreambuf_iterator&lt;char&gt; begin(myFile), end;
string fileDate(begin, end);</Item>
			<Item name="动态数组new delete" tv="10210928">void TestFunc_(unsigned int n)
{
	int (*p)[5] = new int[n][5];//分配10个int[5]类型的空间
	delete[] p;
}
void TestFunc_pointer(unsigned int height, unsigned int width)
{
	//分配的数组空间不连续
	int **p = new int*[height];
	for (int i = 0; i &lt; height; i++)
	{
		p[i] = new int[width];
	}

	for (int i = 0; i &lt; height; i++)
	{
		delete[] p[i];
	}
	delete[] p;
}
void TestFunc_vector(unsigned int height, unsigned int width)
{
	vector&lt;vector&lt;int&gt;&gt; * p = new vector&lt;vector&lt;int&gt;&gt;;
	p-&gt;reserve(height);
	for (int i = 0; i &lt; height; i++)
	{
		p[i].reserve(width);
	}
	delete p;
}
void test_create_2d_vector(unsigned int height, unsigned int width)
{
	vector &lt;vector&lt;int&gt;&gt; vector_2d(height, vector&lt;int&gt;(width,2));
	std::cout &lt;&lt; vector_2d[3][3];
}
</Item></Item>
		<Item name="库" tv="10208352">run,https://github.com/CuPidev/awesome-cpp#json
run,https://python.iitter.com/other/351753.html</Item></Item>
	<Item name="code.exe" tv="10209360">
		<Item name="搜索" tv="10209808">WinActivate, ahk_exe code.exe
ControlSend,,{ctrl down}{shift down}f{shift up}{ctrl up}, ahk_exe code.exe</Item>
		<Item name="高亮" tv="10210032">WinActivate, ahk_exe code.exe
ControlSend,,{alt down}1{alt up}, ahk_exe code.exe</Item>
		<Item name="大纲" tv="10210368">WinActivate, ahk_exe code.exe
ControlSend,,{alt down}f{alt up}, ahk_exe code.exe</Item>
		<Item name="资源" tv="10211040">WinActivate, ahk_exe code.exe
ControlSend,,{ctrl down}{shift down}e{shift up}{ctrl up}, ahk_exe code.exe</Item>
		<Item name="放大" tv="10211376">WinMaximize, ahk_exe code.exe</Item>
		<Item name="终端" tv="10210480">WinActivate, ahk_exe code.exe
ControlSend,,{alt down}3{alt up}, ahk_exe code.exe</Item>
		<Item name="文件" tv="10211152">WinActivate, ahk_exe code.exe
ControlSend,,{shift down}{alt down}r{shift up}{alt up}, ahk_exe code.exe</Item></Item>
	<Item name="Tabby.exe" tv="10211488">
		<Item name="log" tv="10211712">cd /var/opt/gpd_etl_service/data/processing/</Item></Item>
	<Item name="devenv.exe" tv="10215536">
		<Item name="类图" tv="10214864">sendinput,{ctrl down}{alt down}c{alt up}{ctrl up}</Item>
		<Item name="va outline" tv="10214640">sendinput,{alt down}f{alt up}</Item>
		<Item name="注释" tv="10214752">sendinput,{ctrl down}k{ctrl up}
sendinput,{ctrl down}c{ctrl up}</Item>
		<Item name="取消注释" tv="10215424">sendinput,{ctrl down}k{ctrl up}
sendinput,{ctrl down}u{ctrl up}</Item></Item>
	<Item name="@待办" tv="10216880">
		<Item name="计划时间安排" tv="10216656" last="1">run,C:\Users\hetong\Desktop\我的AHK程序\自动化办公\时间安排.xlsx</Item>
		<Item last="1" name="2022年8月9日21:33:49" tv="10217328">你好啊</Item></Item>
	<Item name="msedge.exe" tv="10216544">
		<Item name="控制台" tv="10216096">WinActivate, ahk_exe msedge.exe
ControlSend,,{f12}, ahk_exe msedge.exe</Item>
		<Item name="最大" tv="10217440"></Item>
		<Item name="最小" tv="10217888"></Item>
		<Item name="下一页" tv="10218000"></Item></Item>
	<Item name="python" tv="10216768">
		<Item name="test" tv="10216320">#py
#!/usr/bin/python3

import tkinter
top = tkinter.Tk()
# 进入消息循环
top.mainloop()</Item></Item>
	<Item name="bat" tv="10215088">
		<Item name="test" tv="10214416">::bat
set message=Hello World 
echo %message%</Item>
		<Item name="aa" tv="10215648"></Item>
		<Item name="测试" tv="10214304">
			<Item name="测试" tv="10215200"></Item></Item></Item>
	<Item last="1" name="@网站文件夹" tv="10215312"></Item>
	<Item last="1" name="文件夹">
		<Item last="1" name="新增">run,www.baidu.com ;运行百度</Item></Item>
</Menu>
